# ã€Šæµé›²ã€‹ç¨‹å¼å·¥ç¨‹å¸«æ±‚è·å‰æº–å‚™!
## æœ¬èº«æ˜¯é€šè¨Šç³»ç•¢æ¥­çš„å­¸ç”Ÿï¼Œä¹‹å‰ä½¿ç”¨çš„èªè¨€éƒ½æ˜¯Pythonï¼Œä½†åœ¨æ±‚è·å‰æ‰“ç®—å¥½å¥½çš„å­¸ç¿’C++ä»¥åŠåˆ·LeetCodeï¼Œåœ¨é€™è£¡è¨˜éŒ„ä¸‹å­¸ç¿’éç¨‹ã€‚
### é¡Œå¤–è©±ï¼Œä¸‹æ–¹C++çš„å­¸ç¿’å¿ƒå¾—ä»¥åŠä¾‹é¡Œï¼ŒåŸºæœ¬ä¸Šéƒ½ä¾†è‡ªC++Primer 5thé€™æœ¬æ›¸ï¼Œæ‰€ä»¥å¯ä»¥æ­é…è‘—çœ‹æ›´å¥½å–”!
##  ğŸ“¹[æµé›²çš„ç¨‹å¼ç­†è¨˜Programmer](https://www.youtube.com/@%E6%B5%81%E9%9B%B2%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%AD%86%E8%A8%98)  ğŸ“¹[å½±ç‰‡è¬›è§£-C++å­¸ç¿’å¿ƒå¾—(YouTube)](https://www.youtube.com/watch?v=nxY5JQDC97g)  
### Table of Contents(C++)
>#### â˜ï¸[è¼¸å…¥èˆ‡è¼¸å‡º](https://github.com/littleyu0820/LeetCode_Exercises/blob/main/README.md#1-%E8%BC%B8%E5%85%A5%E8%88%87%E8%BC%B8%E5%87%BA)  
>#### â˜ï¸[è¿´åœˆ](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#2-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%BF%B4%E5%9C%88)
>>#### â˜ï¸[ç·´ç¿’é¡Œ1](https://github.com/littleyu0820/LeetCode_Exercises/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C1)
>>#### â˜ï¸[ç·´ç¿’é¡Œ2](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C2)

>#### â˜ï¸[æ¢ä»¶å¼](https://github.com/littleyu0820/LeetCode_Exercises/blob/main/README.md#3-%E6%A2%9D%E4%BB%B6%E5%BC%8Fif)
>#### â˜ï¸[ç‰©ä»¶å°å‘](https://github.com/littleyu0820/LeetCode_Exercises/blob/main/README.md#3-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91object-oriented)
>>#### â˜ï¸[Classçš„æ‡‰ç”¨èˆ‡ä»‹ç´¹](https://github.com/littleyu0820/LeetCode_Exercises/blob/main/README.md#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%AF%84%E4%BE%8B1class%E7%9A%84%E7%B2%97%E7%95%A5%E8%A7%A3%E7%B4%B9%E8%88%87%E6%87%89%E7%94%A8)
>>#### â˜ï¸[è®€å–/ä½¿ç”¨Classä¸­çš„ç‰¹å®šè³‡æ–™](https://github.com/littleyu0820/LeetCode_Exercises/blob/main/README.md#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%AF%84%E4%BE%8B2%E8%AE%80%E5%8F%96class%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E8%B3%87%E6%96%99)

>#### â˜ï¸[åŸºæœ¬è§€å¿µ](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#4-%E5%9F%BA%E6%9C%AC%E8%A7%80%E5%BF%B5)
>#### â˜ï¸[æŒ‡æ¨™](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#5-%E6%8C%87%E6%A8%99pointer)
>#### â˜ï¸[é™å®šè©](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#6-%E9%99%90%E5%AE%9A%E8%A9%9Econst)
>#### â˜ï¸[è³‡æ–™çµæ§‹](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#7-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8Bdata-structure)
>#### â˜ï¸[å‘½åç©ºé–“](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#8-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%96%93)
>#### â˜ï¸[å­—ä¸²](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#8-%E5%AD%97%E4%B8%B2string)
>>#### â˜ï¸[ç·´ç¿’é¡Œ3](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C3)
>>#### â˜ï¸[ç·´ç¿’é¡Œ4](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C4)
>>#### â˜ï¸[ç·´ç¿’é¡Œ5](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C5)

>#### â˜ï¸[Vector](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#9-vector)
>>#### â˜ï¸[ç·´ç¿’é¡Œ6](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C6)
>>#### â˜ï¸[ç·´ç¿’é¡Œ7](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C7)

>#### â˜ï¸[è¿­ä»£å™¨](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#10-%E8%BF%AD%E4%BB%A3%E5%99%A8iterator)
>>#### â˜ï¸[ç·´ç¿’é¡Œ8](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C8)

>#### â˜ï¸[é™£åˆ—](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#11-%E9%99%A3%E5%88%97array)
>#### â˜ï¸[å¤šç¶­é™£åˆ—](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#12-%E5%A4%9A%E7%B6%AD%E9%99%A3%E5%88%97)
>#### â˜ï¸[é‹ç®—å¼](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#13-%E9%81%8B%E7%AE%97%E5%BC%8Fexpression)
>>#### â˜ï¸[ç·´ç¿’é¡Œ9](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C9)
>>#### â˜ï¸[ç·´ç¿’é¡Œ10](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C10)

>#### â˜ï¸[è¿°å¥](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#14-%E8%BF%B0%E5%8F%A5statement)
>>#### â˜ï¸[ç·´ç¿’é¡Œ11](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C11)
>>#### â˜ï¸[ç·´ç¿’é¡Œ12](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C12)
>>#### â˜ï¸[ç·´ç¿’é¡Œ13](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C13)

>#### â˜ï¸[ä¾‹å¤–(ç•°å¸¸)è™•ç†](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#15-%E4%BE%8B%E5%A4%96%E7%95%B0%E5%B8%B8%E8%99%95%E7%90%86)
>>#### â­â­â­[ç¶œåˆç·´ç¿’](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B6%9C%E5%90%88%E7%B7%B4%E7%BF%92-1)

>#### â˜ï¸[å‡½å¼](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#15-%E5%87%BD%E5%BC%8Ffunction)
>>#### â˜ï¸[ç·´ç¿’é¡Œ14](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C14)

>#### â˜ï¸[å®šç¾©Class](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#16-%E9%A1%9E%E5%88%A5classes)
>#### â˜ï¸[å­˜å–èˆ‡å°è£](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#17-%E5%AD%98%E5%8F%96%E8%88%87%E5%B0%81%E8%A3%9D)
>>#### â˜ï¸[ç·´ç¿’é¡Œ15](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C15)

>#### â˜ï¸[IOç¨‹å¼åº«](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#18-io%E7%A8%8B%E5%BC%8F%E5%BA%AB)
>>#### â˜ï¸[ç·´ç¿’é¡Œ16](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C16)

>#### â˜ï¸[å¾ªåºå®¹å™¨](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#19-%E5%BE%AA%E5%BA%8F%E5%AE%B9%E5%99%A8)
>>#### â˜ï¸[ç·´ç¿’é¡Œ17](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C17)
>>#### â˜ï¸[ç·´ç¿’é¡Œ18](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C18)
>>#### â˜ï¸[ç·´ç¿’é¡Œ19](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C19)
>>#### â˜ï¸[ç·´ç¿’é¡Œ20](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C20)

>#### â˜ï¸[æ³›ç”¨æ¼”ç®—æ³•](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#20-%E6%B3%9B%E7%94%A8%E6%BC%94%E7%AE%97%E6%B3%95)
>#### â˜ï¸[å†æ¢è¿­ä»£å™¨](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#21-%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8)
>>#### â˜ï¸[ç·´ç¿’é¡Œ21](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C21)

>#### â˜ï¸[é—œè¯å¼å®¹å™¨](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#22-%E9%97%9C%E8%81%AF%E5%BC%8F%E5%AE%B9%E5%99%A8)
>>#### â˜ï¸[ç·´ç¿’é¡Œ22](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B7%B4%E7%BF%92%E9%A1%8C22)
>>#### â­â­â­[ç¶œåˆç·´ç¿’](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E7%B6%9C%E5%90%88%E7%B7%B4%E7%BF%92-3)

>#### â˜ï¸[å‹•æ…‹è¨˜æ†¶é«”](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#23-%E5%8B%95%E6%85%8B%E8%A8%98%E6%86%B6%E9%AB%94dynamic-memory)

>#### â˜ï¸[å‹•æ…‹é™£åˆ—](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#24-%E5%8B%95%E6%85%8B%E9%99%A3%E5%88%97dynamic-array)
>>#### [â­â­â­â­â­å¯¦ä½œ](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E5%AF%A6%E4%BD%9C-3)

>#### â˜ï¸[æ‹·è²æ§åˆ¶](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#25-%E6%8B%B7%E8%B2%9D%E6%8E%A7%E5%88%B6)
>>#### [â­â­â­â­â­å¯¦ä½œ](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E5%AF%A6%E4%BD%9C-4)
>>#### [â­â­â­â­â­å¯¦ä½œ](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E5%AF%A6%E4%BD%9C-5)
>>
>>
>#### â­[è£œå……](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#%E8%A3%9C%E5%85%85-1)
### Table of Contents(LeetCode)
>#### â˜ï¸[äºŒåˆ†æœå°‹æ³•(Binary Search)](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#leetcode)
>#### â˜ï¸[æœç´¢æ’å…¥ä½ç½®(Search Insert Position)](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#exercise%E6%87%89%E7%94%A8%E7%B7%B4%E7%BF%92)
>#### â˜ï¸[ç§»é™¤å…ƒç´ (Remove Element)](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#exercise-2)
>#### â˜ï¸[æœ‰åºé™£åˆ—çš„å¹³æ–¹(Squares of a Sorted Array)](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#exercise-3)  
>#### â˜ï¸[é•·åº¦æœ€å°çš„å­é™£åˆ—(Minimum Size Subarray Sum)](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#exercise-4)
>#### â˜ï¸[èºæ—‹çŸ©é™£(Spiral_Matrix)](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#exercise-5)
>#### â˜ï¸[ç§»é™¤åˆ—è¡¨å…ƒç´ (Remove Linked List Elements)](https://github.com/littleyu0820/Interview_Leetode/blob/main/README.md#exercise-6)

# C++
## 1 è¼¸å…¥èˆ‡è¼¸å‡º

```c++
/*
* å‡½å¼åº«<iostream>çš„æ‡‰ç”¨
* istream(cin)/ostream(cout)
* std::cin >> x;
* å°‡è¼¸å…¥çš„å€¼å­˜å–åˆ°è®Šæ•¸x
* std::cout << x << endl;
* å°‡è®Šæ•¸xçš„å€¼å­˜åˆ°coutä¸¦ä¸”é‡‹æ”¾
*/
#includ<iostream>
int main()
{
	std::cout << "This is a test!" << std::endl;
	std::cout << "Please enter two numbers:" << std::endl;
	int v1 = 0, v2 = 0;
	std::cin >> v1 >> v2;
	std::cout << " The sum of " << v1 << " and " << v2 << " is "
		<< v1 + v2 << std::endl;
	return 0;
}
```
### ä»¥ä¸Šé¢é€™æ®µç¨‹å¼ç¢¼ç‚ºä¾‹å­ï¼Œåœ¨C++ä¸­ï¼Œç•¶æˆ‘å€‘è¦é€²è¡Œè¼¸å…¥è¼¸å‡ºï¼Œçš†é ˆå…ˆå¼•å…¥å‡½å¼åº«iostreamã€‚
### iostreamå¯ä»¥åˆ†æˆå…©å€‹éƒ¨åˆ†:istreeam(cin)ä»¥åŠostream(cout)ã€‚
	int  v1 = 0;
### ç¨‹å¼ç¢¼è§£é‡‹:å®£å‘Šè®Šæ•¸v1ã€‚
	std::cin >> v1;
### ç¨‹å¼ç¢¼è§£é‡‹:å°‡è¼¸å…¥çš„å€¼cinå­˜å–åˆ°è®Šæ•¸v1ä¸­ï¼Œä½†æœ€å¾Œé‚„æ˜¯æœƒè¿”å›cin(å¯ä»¥ç”¨ä¾†ç¢ºèªæ˜¯å¦æˆç«‹)ã€‚
	std::cout << v1 << endl;
### ç¨‹å¼ç¢¼è§£é‡‹:å°‡è®Šæ•¸v1å­˜åˆ°coutä¸­ï¼Œä¸¦ä¸”é‡‹æ”¾ã€‚
### æ³¨:endlæ˜¯ç”¨ä¾†å°‡ç·©è¡å€(buffer)çš„å…§å®¹é‡‹æ”¾åˆ°é¡¯ç¤ºå™¨ä¸Šçš„ã€‚

## 2 æµç¨‹æ§åˆ¶(è¿´åœˆ)
### ä¸€èˆ¬ä¾†èªªï¼Œç¨‹å¼ç¢¼çš†æ˜¯é †åºåŸ·è¡Œçš„ï¼Œä½†æˆ‘å€‘ä¹Ÿå¯ä»¥é€šéè¿´åœˆçš„æ–¹å¼ä¾†å¢åŠ ç‰¹å®šæ¢ä»¶ã€‚
### while:åè¦†åŸ·è¡ŒæŸæ®µç¨‹å¼ï¼Œç›´åˆ°çµ¦å®šçš„æ¢ä»¶ç‚ºå‡(false)ã€‚
```c++
#include <iostream>  
int main()
{
	int sum = 0, val = 1;
	while (val <= 10) //if val is less than or equal to 10 keep running the loop
	{
		sum += val; // keep adding val to sum
	        ++val; // increment val by 1 each loop
	}
	std::cout << "The sum is: " << sum << std::endl;
	return 0;
}
```
### for:ç‚ºäº†ç°¡åŒ–è¿´åœˆå…§æ¢ä»¶è®Šæ•¸çš„å¢æ¸›è€Œå°ˆé–€å®šç¾©å‡ºä¾†çš„ï¼Œç°¡åŒ–æ­¥é©Ÿã€‚
### for(è®Šæ•¸åˆå§‹å€¼;æ¢ä»¶;è®Šæ•¸å¢æ¸›)
### åŸ·è¡Œé †åº:è®Šæ•¸åˆå§‹å€¼â¡ï¸æ¢ä»¶â¡ï¸forå…§ç¨‹å¼ç¢¼â¡ï¸è®Šæ•¸å¢æ¸›â¡ï¸æ¢ä»¶â¡ï¸forå…§ç¨‹å¼ç¢¼â¡ï¸.....
```c++
#include <iostream>  
int main()
{	
	int sum = 0;
	for (int i = 0; i <= 10; ++i)
	{
		sum += i;
	}
	std::cout << "The sum is: " << sum << std::endl;
	return 0;
}
```

## ç·´ç¿’é¡Œ1
>æ ¹æ“šä½¿ç”¨è€…è¼¸å…¥çš„å€¼æ±‚ç¸½å’Œ
### æ–¹æ³•:
```c++
int main()
{

	int sum = 0, val = 0;

	while (std::cin >> val) //if "ctrl+z"(windows) or ";" is pressed, the loop will break
	{
		sum += val;
	}

	std::cout << "The sum is: " << sum << std::endl;
	return 0;

}
```
## ç·´ç¿’é¡Œ2
>æ ¹æ“šä½¿ç”¨è€…è¼¸å…¥å…©å€‹æ•¸ï¼Œå°å‡ºå…¶ç¯„åœå…§çš„æ‰€æœ‰æ•¸å€¼
### æ–¹æ³•:
```c++
/*
*è®“ä½¿ç”¨è€…è¼¸å…¥å…©å€‹æ•´æ•¸ï¼Œç„¶å¾Œå°å‡ºé€™å…©å€‹æ•¸å­—ç¯„åœå…§çš„æ‰€æœ‰æ•¸å­—
*/

#include<iostream>

int main()
{
	int val1 = 0, val2 = 0, currval = 0;

	std::cout << "Please enter two numbers: " << std::endl;
	std::cin >> val1 >> val2;

	if (val1 > val2) //check if the first number is bigger or not
	{
		currval = val2; //the result will start from the smaller one
		while (currval <= val1) //if the currval is greater than the first number, the loop will break
		{
			std::cout << currval << std::endl; //print the result from the smaller one
			++currval; //increment the result by 1
		}
	}
	else
	{
		currval = val1; //the result will start from the smaller one
		while (currval <= val2) //if the currval is greater than the second number, the loop will break
		{
			std::cout << currval << std::endl; //print the result from the smaller one
			++currval; //increment the result by 1
		}
	}

	return 0;
}
```
## 3 æ¢ä»¶å¼(if)
### ç•¶ç‰¹å®šæ¢ä»¶æˆç«‹æ™‚ï¼Œæ‰æœƒåŸ·è¡Œã€‚
### ç¨‹å¼ç¢¼ç¯„ä¾‹:
```c++
#include<iostream>
int main()
{
	int counter = 0, val = 0, currentval = 0;
	if (std::cin >> currentval) //if the first input is successful
	{	
		++counter; //counter is incremented by 1
		while (std::cin >> val) //if the next input is successful
		{
			if (val == currentval) //check if the current input is equal to the previous input or not
			{
				++counter;
			}
			else
			{
				std::cout << "The past number " << currentval << " occurs " << counter << " times." << std::endl; //print the previous number
				std::cout << "And the current value is: " << val << std::endl;
				currentval = val; //assign the current value to the previous value
				counter = 1; //reset the counter
			}
		}		
		std::cout << "The past number " << currentval << " occurs " << counter << " times." << std::endl; //print the previous number
		std::cout << "And the current value is: " << val << std::endl;
		return 0;
	}
	else
	{
		std::cout << "Invalid input." << std::endl;
		return -1;
	}
}
}
```
### è¦è¨˜å¾—ï¼Œç•¶æˆ‘å€‘æ¯æ¬¡å¥—ç”¨std::cinæ™‚ï¼Œä»£è¡¨çš„éƒ½æ˜¯ä¸€å€‹æ–°çš„é–‹å§‹ï¼Œä»¥ä¸‹é¢é€™å¹¾æ®µç¨‹å¼ç¢¼(ä¸­é–“å…§å®¹çœç•¥)ç‚ºä¾‹:
```c++
if (std::cin >> currentval) //if the first input is successful
	{		
		++counter; //counter is incremented by 1
		while (std::cin >> val) //if the next input is successful
		{
			...
		}
	}
```
### å…¶ä¸­ç¬¬ä¸€æ®µçš„ifæ¢ä»¶å¼ï¼Œæ˜¯ç”¨ä¾†åˆ¤æ–·ï¼Œç•¶æˆ‘å€‘"ç¬¬ä¸€æ¬¡"è®€å–è¼¸å…¥çš„å€¼æ™‚ï¼Œæ˜¯å¦æˆç«‹ï¼Œå¦‚æœæˆç«‹è¨ˆæ•¸å™¨åŠ ä¸€ï¼Œä¸¦ä¸”ç¹¼çºŒå‘ä¸‹åŸ·è¡Œã€‚
### è€Œå…¶ä¸­ç¬¬å››æ®µçš„whileè¿´åœˆï¼Œå‰‡æ˜¯è®“æˆ‘å€‘åˆ¤æ–·"ç¬¬äºŒæ¬¡"ã€"ç¬¬ä¸‰æ¬¡"ã€....ï¼Œæ‰€è¼¸å…¥çš„å€¼æ˜¯å¦æˆç«‹ã€‚
### å¾é€™å…©æ¢ç¨‹å¼ç¢¼ï¼Œæˆ‘å€‘å°±èƒ½å¤ çœ‹å‡ºï¼Œæ¯ä¸€æ¬¡cinçµæŸä¹‹å¾Œï¼Œå°±æ˜¯å®Œå…¨çµæŸäº†ï¼Œèˆ‡å…ˆå‰çš„æ‰€æœ‰çµæœéƒ½ç„¡é—œã€‚

## 3 ç‰©ä»¶å°å‘(Object Oriented):
### é€šéclassçš„æ–¹å¼ä¾†å®šç¾©è‡ªå·±çš„æ•¸æ“šçµæ§‹(è©³ç´°è³‡æ–™)ã€‚
### ç¨‹å¼ç¢¼ç¯„ä¾‹1(classçš„ç²—ç•¥ä»‹ç´¹èˆ‡æ‡‰ç”¨):
```c++
#include<iostream>
#include"Sales_item.h"

int main()
{
	Sales_item book;

	std::cin >> book; //read ISBN, numbers of sold, the price of each book
	std::cout << book << std::endl; //write ISBN, numbers of sold, total revenue, the price of each book

	return 0;
}
```
```c++
#include"Sales_item.h"
```
### ç¨‹å¼ç¢¼è§£é‡‹:å¼•ç”¨æ¨™é ­æª”(Header file)ã€‚
```c++
Sales_item book;
```
### ç¨‹å¼ç¢¼è§£é‡‹:å°æ¯ä¸€æœ¬æ›¸é€²è¡Œå®šç¾©ã€‚
### é€™æ¨£èªªå¯èƒ½æœ‰äº›æŠ½è±¡ï¼Œç”¨ä¸€å€‹ç°¡å–®çš„ä¾‹å­ä¾†èªªï¼Œç•¶æˆ‘å€‘åœ¨çœ‹ä¸€å€‹äººæ™‚ï¼Œå¯ä»¥é€šéå§“åã€æ€§åˆ¥ã€å¹´ç´€ã€èº«é«˜é«”é‡ï¼Œç”šè‡³æ˜¯æ€§æ ¼ï¼Œä¾†å®šç¾©é€™å€‹äººï¼Œè€Œä¸Šé¢é€™æ®µç¨‹å¼ç¢¼ä¹Ÿæ˜¯ä¸€æ¨£çš„æ„æ€ã€‚
```c++
std::cin >> book; //read ISBN, numbers of sold, the price of each book
```
### ç¨‹å¼ç¢¼è§£é‡‹:å¯ä»¥ç™¼ç¾ï¼Œé€™è£¡çš„std::cinèˆ‡åŸæœ¬çš„æ“ä½œæ¨¡å¼æœ‰æ‰€ä¸åŒï¼Œé€™è£¡æ˜¯ç”¨ä¾†è®€å–ä¸€é€£ä¸²çš„æ•¸å€¼(æ›¸çš„è©³ç´°è³‡æ–™)
```c++
std::cout << book << std::endl; //write ISBN, numbers of sold, total revenue, the price of each book
```
### ç¨‹å¼ç¢¼è§£é‡‹:èˆ‡åŸæœ¬çš„std::coutä¸åŒï¼Œé€™è£¡ä¸åƒ…å¯«å‡ºbookåŸæœ¬çš„è³‡æ–™ï¼Œé‚„å¯ä»¥ç›´æ¥å¾—åˆ°æˆ‘å€‘è¦çš„æ‰€æœ‰çµæœã€‚

### ç¨‹å¼ç¢¼ç¯„ä¾‹2(è®€å–classä¸­çš„ç‰¹å®šè³‡æ–™):
```c++
#include<iostream>
#include"Sales_item.h"

int main()
{
	Sales_item item1, item2;
	std::cin >> item1 >> item2; //read each data from the input
	if (item1.isbn() == item2.isbn()) //check if the isbn of the two books are same or not
	{
		std::cout << item1 + item2 << std::endl; //print the sum of the two books
		return 0;
	}
	else
	{
		std::cerr << "Data must refer to the same ISBN" << std::endl;
		return -1;
	}
}
```
```c++
if (item1.isbn() == item2.isbn())
```
### ç¨‹å¼ç¢¼è§£é‡‹:é€šé".isbn"çš„æ–¹å¼ï¼Œèª¿ç”¨item1ä¸­çš„isbnå€¼ã€‚

## 4 åŸºæœ¬è§€å¿µ:
### 1. C++æ˜¯ä¸€ç¨®éœæ…‹çš„èªè¨€ï¼Œæ‰€è¬‚éœæ…‹ï¼Œä»£è¡¨è‘—å°±æ˜¯åœ¨ç·¨è­¯æ™‚ï¼Œæˆ‘å€‘å°±æœƒå°æ‰€æœ‰è®Šæ•¸åšå‹åˆ¥çš„æª¢æŸ¥ã€‚
### é›»è…¦æ˜¯ä»¥bit(0/1)ç‚ºåŸºæœ¬å–®ä½åšå­˜å„²çš„ï¼Œè€Œæ¯ä¸€å€‹æœ€å°è¨˜æ†¶é«”çµ„å¡Š(1byte)å‰‡æ˜¯ç”±8å€‹bitæ‰€çµ„æˆçš„ã€‚
### 2. æˆ‘å€‘é‚„å¯ä»¥å°è®Šæ•¸åšæœ‰è™Ÿ(signed)æˆ–ç„¡è™Ÿ(unsigned)çš„å®šç¾©:
### æœ‰è™Ÿä»£è¡¨è‘—è² ã€æ­£ï¼Œç”šè‡³æ˜¯é›¶çš„æ•¸å­—;è€Œç„¡è™Ÿå‰‡åªèƒ½è¡¨ç¤ºå¤§æ–¼ç­‰æ–¼é›¶çš„å€¼ã€‚
### 3. å®£å‘Šèˆ‡å®šç¾©:ç”¨ç¬¬ä¸€é»æˆ‘å€‘æ‰€æåˆ°çš„æ¦‚å¿µä¾†èªªï¼ŒC++æœƒæ˜ç¢ºçš„è¦æ±‚æˆ‘å€‘åœ¨ä½¿ç”¨æŸä¸€è®Šæ•¸æ™‚ï¼Œå°±è¦å…ˆé€²è¡Œå®£å‘Šäº†ï¼Œè€Œæ‰€è¬‚å®£å‘Šå’Œå®šç¾©ï¼Œåˆæœ€ç°¡å–®çš„è©±ä¾†è¬›ï¼Œå°±æ˜¯ä½ æœ‰æ²’æœ‰èªªï¼‚æ¸…æ¥šï¼‚ã€‚ã€€
### èˆ‰ä¾‹ä¾†èªªï¼Œæœ‰ä¸€å€‹äººå«åšè€ç‹ï¼Œä½†ä½ åªçŸ¥é“ä»–å«åšè€ç‹ï¼Œä¸çŸ¥é“ä»–æ˜¯ç”·æ˜¯å¥³ï¼Œä»–çš„èº«é«˜é«”é‡ã€å¹´ç´€...ç­‰ï¼Œé€™å°±æ˜¯å®£å‘Šï¼›è€Œå®šç¾©å°±æ˜¯ï¼Œä½ æ˜ç¢ºçš„è¢«å‘ŠçŸ¥ï¼Œé‚£äººå«è€ç‹ï¼Œæ˜¯ç”·çš„ï¼Œæœ‰å¤šé«˜å¤šé‡ï¼Œç”šè‡³æ˜¯å¹¾æ­²ã€‚
### åœ¨ï¼£++æˆ‘å€‘å¯ä»¥ç”¨é—œéµå­—"extern"ä¾†åšå®£å‘Š(ç”¨ä¾†å­˜å–åœ¨å…¶ä»–åœ°æ–¹å°±è¢«å®šç¾©çš„è®Šæ•¸:
```c++
extern int i; //åªå®£å‘Šiï¼Œè‡³æ–¼içš„å…§å®¹ï¼Œå»å¤–é¢æ‹¿
int j = 1; //å®šç¾©ä¸”å®£å‘Š
```
### è®Šæ•¸åªèƒ½å®šç¾©ä¸€æ¬¡ï¼Œä½†å¯ä»¥è¢«å®£å‘Šç„¡æ•¸æ¬¡ã€‚
### 4. C++çš„è­˜åˆ¥å­—(identifier)å¿…é ˆç”±å­—æ¯æˆ–åº•ç·šç‚ºé–‹é ­ï¼Œä¸”å€åˆ†å¤§å°å¯«ã€‚
### 5. é€šå¸¸æˆ‘å€‘åœ¨å®šç¾©ä¸€å€‹è®Šæ•¸çš„åç¨±æ™‚ï¼Œéƒ½æ˜¯ç”±å°å¯«çµ„æˆï¼Œè€Œå®šç¾©ä¸€å€‹é¡åˆ¥(class)å‰‡æ˜¯ç”±å¤§å¯«ç‚ºé–‹é ­ã€‚
### 6. è¦è¨˜å¾—ï¼Œå¦‚æœå®šç¾©äº†ä¸€å€‹ç”±å¤šå€‹å–®å­—çµ„æˆçš„è®Šæ•¸æˆ–é¡åˆ¥ï¼Œè¦ç”¨åº•ç·šå€åˆ†é–‹æ¯ä¸€å€‹å–®å­—ã€‚
### 7. ç¬¬äº”é»è·Ÿç¬¬å…­é»ä¸¦ä¸æ˜¯çµ•å°çš„ï¼Œä½†å»æ˜¯æˆ‘å€‘å¯«ç¨‹å¼æ™‚æ‰€æœƒç”¨åˆ°çš„æ…£ä¾‹(convention)ã€‚
### 8. ç•¶æˆ‘å€‘åˆå§‹åŒ–ä¸€å€‹è®Šæ•¸æ™‚æ™‚ï¼Œå¦‚:
```c++
int ival = 1024;
```
### é€™ä»£è¡¨æˆ‘å€‘å°‡1024æ”¾é€²(æ‹·è²)ï¼Œåˆ°ivalè£¡é¢ã€‚ä½†å¦‚æœæˆ‘å€‘é€™æ™‚å€™ç”¨è¤‡åˆå‹åˆ¥ä¸­çš„"åƒè€ƒ(references)"ï¼Œçµæœæœƒä¸€æ¨£ï¼Œä½†éç¨‹å¤§ä¸ç›¸åŒï¼Œå¦‚ä¸‹:
```c++
int &refval = ival;
```
### åœ¨é€™è£¡ï¼Œæˆ‘å€‘å¾—åˆ°çš„çµæœï¼Œä¸€æ¨£æœƒæ˜¯1024ï¼Œä½†å»ä¸åŒæ–¼åˆå§‹åŒ–ï¼Œæˆ‘å€‘ä¸¦éæ˜¯å°‡ivalæ”¾é€²refvalä¸­ï¼Œè€Œæ˜¯å°‡refvalç¹«çµ(bind)ï¼Œç•¶ç„¶æˆ‘æœ¬èº«æ¯”è¼ƒå–œæ­¡èªªç¶åˆ°ivalä¸Šé¢ã€‚
### ç•¶ç„¶æˆ‘å€‘ä¹Ÿè¦æ³¨æ„ï¼Œåšå®Œåƒè€ƒåˆå§‹åŒ–å¾Œï¼Œå°±å·²ç¶“ç¶å®šäº†ï¼Œä½ ç„¡æ³•å†å°‡å®ƒç¶å®šåˆ°å…¶å®ƒç‰©ä»¶ä¸Šã€‚

## 5 æŒ‡æ¨™(pointer):
### 1. æŒ‡æ¨™æ˜¯ä¸€ç¨®å°ä½å€(address)çš„å°è£ï¼Œä¹Ÿå°±æ˜¯ç”¨ä¾†å­˜æ”¾å¦ä¸€å€‹ç‰©ä»¶çš„ä½å€ã€‚åŒæ™‚èˆ‡åƒè€ƒ(references)ä¸åŒï¼ŒæŒ‡æ¨™æœ¬èº«å°±æ˜¯ä¸€å€‹ç‰©ä»¶(æœ‰è‡ªå·±çš„ç©ºé–“)ã€‚
### 2. ç•¶æˆ‘å€‘å®šç¾©æŒ‡æ¨™æ™‚ï¼Œæœƒåœ¨è®Šæ•¸å‰é¢ç”¨ä¸Š"*"ã€‚
```c++
int *ip1;
```
### 3. å¦‚æœæˆ‘å€‘æ²’æœ‰å°æŒ‡æ¨™é€²è¡Œåˆå§‹åŒ–ï¼Œé‚£éº¼å®ƒå°‡æœƒæ“æœ‰ä¸€å€‹ä¸ç¢ºå®šçš„å€¼ã€‚
### 4. é€šé"&"ä¾†å­˜å–ç›®æ¨™ç‰©ä»¶çš„ä½å€ã€‚
```c++
int ival = 42; //ivalæ˜¯ä¸€å€‹intå‹åˆ¥çš„è®Šæ•¸ï¼Œå…§å®¹ç‚º42
int *ip1 = &ival; //ip1æ˜¯ä¸€å€‹intçš„æŒ‡æ¨™ã€‚åŒæ™‚ï¼Œæˆ‘å€‘å°‡å­˜å–ivalçš„ä½å€ã€‚
std::cout << *ip1 << std::endl; //å°‡æŒ‡æ¨™ç›®å‰ä½å€æ‰€å­˜æ”¾çš„å…§å®¹é‡‹æ”¾å‡ºä¾†
```
![Pointer](https://github.com/littleyu0820/Interview_Leetode/blob/main/PitcturesForLearning/pointer.png)

### 5. æŒ‡æ¨™çš„å‹åˆ¥å¿…é ˆèˆ‡æ‰€æŒ‡çš„ç‰©ä»¶ç›¸åŒï¼Œä½†void*å»ä¸ç”¨ï¼Œå¦‚ä¸‹:
```c++
double obj = 3.14, *pd;
*pd = &obj; //objèˆ‡pdéƒ½æ˜¯double
void *pv;
pv = &obj; //pvæ˜¯ä¸€å€‹voidå‹åˆ¥çš„æŒ‡æ¨™ï¼Œæ‰€ä»¥å¯ä»¥éš¨æ„åœ°æŒ‡å‘ä»»æ„ç‰©ä»¶ã€‚
```
### 6. å¦‚æˆ‘å€‘å‰é¢ç¬¬ä¸€é»æ‰€èªªï¼ŒæŒ‡æ¨™ä¹Ÿæ˜¯ä¸€å€‹ç‰©ä»¶ï¼Œæ‰€ä»¥æˆ‘å€‘å¯ä»¥å¦ä¸€å€‹æŒ‡æ¨™ï¼ŒæŒ‡å‘æŒ‡æ¨™ï¼Œé€™æœ‰é»æŠ½è±¡ï¼Œæˆ‘å€‘ç›´æ¥çœ‹ä¾‹å­:
```c++
int ival = 1024;
int *pi = &ival; //å–ivalçš„ä½å€ï¼Œå…§å®¹ç‰©ç‚º1024
int **ppi = &pi; //å–piçš„ä½å€ï¼Œå…§å®¹ç‰©ä¹Ÿç‚º1024
```

## 6 é™å®šè©(const):
### 1. ç•¶æˆ‘å€‘å®šç¾©ä¸€å€‹è®Šæ•¸ç‚ºconstæ™‚ï¼Œä»£è¡¨è‘—æˆ‘å€‘ä¸èƒ½å†å°å…¶åšä»»ä½•æ”¹è®Šäº†ï¼Œå¦‚ä¸‹:
```c++
const int bufSize = 512 //bufSizeè¢«å›ºå®šåœ¨512ï¼Œä¸èƒ½å†è¢«æ”¹è®Šäº†ã€‚
```
### 2. é€šå¸¸è¢«å®šç¾©ç‚ºconstçš„ç‰©ä»¶æ˜¯ä¾·é™æ–¼åŒä¸€å€‹å€åŸŸ(æª”æ¡ˆ)å…§çš„ï¼Œå¦‚æœæˆ‘å€‘è¦å†å¤–éƒ¨ä½¿ç”¨å®ƒï¼Œéœ€è¦å†å‰æ–¹åŠ ä¸Šexternã€‚
```c++
extern const int bufSize = 512
```

## 7 è³‡æ–™çµæ§‹(Data Structure):
### èˆ‡classåšå€åˆ¥ï¼Œclassç‚ºprivateè€Œstructå‰‡æ˜¯publicã€‚
```c++
struct Sales_data //ISBN, numbers of sold, the price of each book
{
	std::string book_Numbers;
	unsigned int numbers_sold = 0;
	double price = 0.0;
};
```
![Structure](https://github.com/littleyu0820/Interview_Leetode/blob/main/PitcturesForLearning/structure.png)
### è¨»:è¦è¨˜å¾—structæœ€å¾Œè¦åŠ ä¸Š";"

## 8 å‘½åç©ºé–“:
### å¤§å®¶å¯ä»¥ç™¼ç¾ï¼Œæˆ‘å€‘æ¯æ¬¡ä½¿ç”¨cinã€coutï¼Œåˆæˆ–è€…æ˜¯endlæ™‚ï¼Œéƒ½æœƒåœ¨å‰é¢åŠ ä¸Š"std::"ï¼Œä¸»è¦åŸå› åœ¨æ–¼ï¼Œå®ƒå€‘ä¸‰å€‹éƒ½æ˜¯å­˜æ–¼stdé€™å€‹å‘½åç©ºé–“è£¡é¢çš„ã€‚
### èˆ‰ä¾‹ä¾†èªªï¼Œä½ ç¾åœ¨æƒ³åƒæ°´æœå£å‘³çš„ç³–æœï¼Œä½†æ˜¯æ¡Œä¸Šå»æœ‰ä¸‰åŒ…ä¸åŒç¨®é¡çš„ç³–æœï¼Œä½ å°±å¿…é ˆå¾ˆæ˜ç¢ºåœ°å‘Šè¨´åˆ¥äººï¼Œä½ è¦åƒå¾—æ˜¯å“ªä¸‰ç¨®ç³–æœï¼Œé€™æ¨£äººå®¶æ‰å¯ä»¥æ‹¿å‡ºä½ æƒ³è¦çš„ã€‚
### è€Œåœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œæˆ‘å€‘å°±æœƒé€šé"std::"çš„æ–¹å¼ä¾†ä½¿ç”¨ï¼Œç•¶ç„¶æ¯ä¸€æ¬¡éƒ½é€™éº¼ç”¨ç¢ºå¯¦æœ‰äº›ç¹é›œï¼Œæ‰€ä»¥æˆ‘å€‘å¯ä»¥é€šéä»¥ä¸‹å…©ç¨®æ–¹å¼ä¾†ç°¡åŒ–ã€‚
```c++
using std::cin;
using std::cout;
using std::endl;
```
### åˆæˆ–è€…æ˜¯ç›´æ¥:
```c++
using namespace std;
```
### ç•¶ç„¶è¦è¨˜å¾—çš„æ˜¯ï¼Œåœ¨æ¨™é ­æª”(Header File)ä¸­ä¸è¦ä½¿ç”¨usingçš„å®£å‘Šçš„å–”!
### é¡Œå¤–è©±ï¼Œæˆ‘æœ¬èº«é‚„æ˜¯ç¿’æ…£ä½¿ç”¨"std::"çš„æ–¹å¼ä¾†å¯«ç¨‹å¼ï¼ŒåŒæ™‚å¦‚æœå¤§å®¶çœŸçš„è¦ç°¡åŒ–çš„è©±ï¼Œä¹Ÿè¨˜å¾—ç”¨ç¬¬ä¸€ç¨®æ–¹å¼æœƒæ¯”è¼ƒå¥½ï¼Œé€™æ¨£ä½ åˆæˆ–è€…æ˜¯è®€æŸç¯‡ç¨‹å¼ç¢¼çš„äººï¼Œæ‰æœƒæ˜ç¢ºå¾—æ¸…æ¥šï¼Œåˆ°åº•ä½¿ç”¨äº†é‚£äº›å®£å‘Šäº†ã€‚

## 8 å­—ä¸²(string):
### 1. å°æ–¼stringçš„å®šç¾©ï¼Œé€šå¸¸æœ‰ä¸‹é¢å¹¾ç¨®æ–¹æ³•:
```c++
std::string s1; //é€™æ˜¯ä¸€å€‹ç©ºçš„å­—ä¸²(null)
std::string s2 = s1; //å°‡s1çš„å€¼è¤‡è£½åˆ°s2ä¸­
std::string s3 = "hiya; //å°‡hiyaè¤‡è£½åˆ°s3ä¸­
std::string s4(10, 'c'); //cccccccccc
```
### å…¶ä¸­ç¬¬ä¸‰ç¨®æ–¹æ³•çš„è¤‡è£½æµç¨‹å¤§è‡´å¦‚ä¸‹:
```c++
std::string temp = "hiya";
std::string s3 = temp;
```
### 2. èˆ‡å‰é¢ç¬¬ä¸€ç« æåˆ°çš„è¼¸å…¥èˆ‡è¼¸å‡ºä¸€æ¨£ï¼Œç•¶æˆ‘å€‘åœ¨åšcinæ™‚ï¼Œæ˜¯è®€å–åˆ°ç©ºç™½å°±åœæ­¢äº†ï¼Œå¦‚ä¸‹:
```c++
std::string s1;
std::cin >> s1;
std::cout << s1 << std::endl;
```
### ä»¥ä¸Šé¢é€™æ®µç¨‹å¼ç¢¼ç‚ºä¾‹ï¼Œå¦‚æœæˆ‘å€‘è¼¸å…¥çš„æ˜¯"hello world"ï¼Œé‚£æœ€å¾Œè¼¸å‡ºçš„çµæœåªæœƒæ˜¯"hello"ï¼Œå› ç‚ºcinåœ¨ç¢°åˆ°helloå°±çµæŸä¸¦å›å‚³äº†ã€‚
### 3. ç•¶ç„¶æˆ‘å€‘ä¹Ÿå¯ä»¥é€£çºŒè¼¸å…¥ï¼Œå¦‚ä¸‹:
```c++
std::string s1,s2;
std::cin >> s1 >> s2;
std::cout << s1 << s2 << std::endl;
```
### å¦‚æœæˆ‘å€‘è¼¸å…¥çš„æ˜¯"helloè·Ÿworld"ï¼Œé‚£æœ€å¾Œè¼¸å‡ºçš„çµæœåªæœƒæ˜¯"helloworld"ã€‚
### 4. è€Œé€šå¸¸æˆ‘å€‘åœ¨è¼¸å…¥ä¸€ä¸²å¥å­æ™‚ï¼Œç©ºç™½æ˜¯ä¸å¯é¿å…çš„ï¼Œé€™æ™‚å€™æˆ‘å€‘å°±æœƒç”¨getlineä¾†å¯¦ç¾ï¼Œå¦‚ä¸‹:
```c++
std::string test_line;
getline(std::cin, test_line); //read the input from the user and store it into the test_line
std::cout << test_line << std::endl;
```
### 5. stringä¸­é‚„æœ‰ä¸€äº›ç‰¹æ®Šçš„å‡½å¼å¯ä»¥ä½¿ç”¨ï¼Œå¦‚empty()è·Ÿsize()ï¼Œé€™è£¡å…ˆè¬›empty():
### empty()å¦‚å…¶åï¼Œå°±æ˜¯ç”¨ä¾†åˆ¤æ–·stringæ˜¯å¦ç‚ºç©º(null)ï¼Œè€Œåˆ¤æ–·èˆ‡æ˜¯å¦ï¼Œé€™äº›å­—è©å°±å¯ä»¥é¦¬ä¸Šè®“æˆ‘å€‘äº†è§£åˆ°ï¼Œä»–å›å‚³çš„ä¸€å®šå°±æ˜¯ä¸€å€‹boolå€¼(true/false)ã€‚
### è¨»è¨˜:ç©ºæ ¼ä¸å±¬æ–¼ç©ºå–”!
### æ¥ä¸‹ä¾†æåˆ°çš„æ˜¯size()ï¼Œä¹Ÿæ˜¯çœ‹åå­—å°±çŸ¥é“äº†ï¼Œsize()ï¼Œå°±æ˜¯ç”¨ä¾†åˆ¤æ–·å­—ä¸²å¤§å°çš„ï¼Œæ‰€ä»¥ç„¡åº¸ç½®ç–‘çš„ï¼Œä»–ä¸€å®šæ˜¯ä¸€å€‹unsignedï¼Œä½†æœ‰ä¸€é»å¾ˆé‡è¦ï¼Œsize()ä¸¦éintå‹ï¼Œè€Œæ˜¯string::size_typeçš„å‹åˆ¥ã€‚
### é‚£å¦‚æœæˆ‘å€‘æ¯æ¬¡éƒ½è¦å®£å‘Šä¸€æ¬¡string::size_typeä¹Ÿå¤ªéº»ç…©ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨ä»¥ä¸‹æ–¹æ³•ä¾†å®£å‘Š:
```c++
std::string test_line;
getline(std::cin, test_line); //read the input from the user and store it into the test_line
auto len = test_line.size(); //store the size of the test_line into the len
std::cout << len << std::endl;
```
### é€šéautoçš„æ–¹å¼è®“ç·¨è­¯å™¨è‡ªå·±æä¾›é©ç•¶çš„å‹åˆ¥ã€‚
### è¨»è¨˜:å› ç‚ºsize()å±¬æ–¼unsignedï¼Œæ‰€ä»¥ä¸è¦è·Ÿintåšæ¯”è¼ƒå–”!
### 6. stringä¹Ÿå¯ä»¥åšç›¸åŠ çš„ï¼Œå¦‚ä¸‹:
### é¦–å…ˆæœ€é‡è¦çš„ï¼Œå…©å€‹stringç›¸åŠ é‚„æ˜¯stringï¼Œå†ä¾†"+"å…©é‚Šå¿…ç„¶è¦å­˜åœ¨ä¸€å€‹stringï¼Œæˆ‘å€‘ç›´æ¥çœ‹ä¾‹å­ã€‚
```c++
std::string s1, s2;
std::string s3 = s1 + s2; //æˆç«‹ï¼Œå…©é‚Šéƒ½æ˜¯stringï¼Œä¸å¿…å¤šèªª
std::string s4 = s1 + "test"; //æˆç«‹ï¼Œå…¶ä¸­ä¸€é‚Šç‚ºstring
std::string s5 = "test" + s2; //æˆç«‹ï¼Œå…¶ä¸­ä¸€é‚Šç‚ºstring
std::string s6 = s1 + "," + "test"; //æˆç«‹ï¼Œå› ç‚ºs1 + ","ï¼Œé‚„æ˜¯string
std::string s7 = "hi" + "," + "test"; //ä¸æˆç«‹ï¼Œ"+"å…©é‚Šéƒ½æ²’æœ‰string
std::string s8 = "hi" + "," + s2; //ä¸æˆç«‹ï¼Œç¬¬ä¸€æ¬¡ç›¸åŠ å°±éŒ¯èª¤äº†ï¼Œå…©é‚Šéƒ½æ²’æœ‰string
std::string s9 = "hi" + ("," + s2); //æˆç«‹ï¼Œå› ç‚ºå…ˆåšå¾Œé‚Šæ‹¬è™Ÿå…§çš„é‹ç®—
```
### 7. é€šå¸¸å¦‚æœæˆ‘å€‘è¦è™•ç†stringçš„æ¯å€‹å­—å…ƒï¼Œéƒ½æœƒç”¨forçš„æ–¹å¼ä¾†åš:
```c++
std::string test_line;
getline(std::cin, test_line); //read the input from the user and store it into the test_line
for (auto test : test_line) //for each character in the test_line
{
	std::cout << test << std::endl; 
}
```
## ç·´ç¿’é¡Œ3
>æ ¹æ“šä½¿ç”¨è€…è¼¸å…¥çš„å­—ä¸²ï¼Œå°‡å…¶å…¨éƒ¨è½‰æ›ç‚ºå¤§å¯«
### æ–¹æ³•:
```c++
#include<iostream>
#include<string>
int main()
{
	std::string user_input;
	getline(std::cin, user_input); //read the input from the user and store it into the user_input
	for (auto &change_character : user_input) //for each character in the test_line and remember that change_character is reference
	{
		change_character = toupper(change_character); //since change_character is reference, the change will be reflected in the user_input
	}
	std::cout << user_input << std::endl;	
	return 0;
}
```
### 8. ç•¶æˆ‘å€‘è¦ç”¨indexå»å­˜å–stringæ™‚ï¼Œä¸€å®šè¦è¨˜å¾—åˆ¤æ–·è©²stringæ˜¯å¦ç‚ºç©ºã€‚
## ç·´ç¿’é¡Œ4
>æ ¹æ“šä½¿ç”¨è€…è¼¸å…¥çš„å­—ä¸²ï¼Œå°‡å…¶è½‰æ›ç‚ºå¤§å¯«ï¼Œç›´åˆ°ç¢°åˆ°ç©ºæ ¼ç‚ºæ­¢(ä¹Ÿå°±æ˜¯åªè½‰æ›ç¬¬ä¸€å€‹å–®å­—)ã€‚
### æ–¹æ³•:
```c++
#include<iostream>
#include<string>
int main()
{
	std::string user_input;
	decltype(user_input.size()) index = 0; 
	getline(std::cin, user_input); //read the input from the user and store it into the user_input
	while (index < user_input.size() && !isspace(user_input[index]))
	{
		user_input[index] = toupper(user_input[index]); //convert the character to uppercase
		++index;
	}
	std::cout << user_input << std::endl; 	
	return 0;
}
```
## ç·´ç¿’é¡Œ5
>æ ¹æ“šä½¿ç”¨è€…è¼¸å…¥çš„æ•¸å­—ï¼Œå°‡å…¶è½‰æ›ç‚ºåå…­é€²ä½ï¼ŒåŒæ™‚ç¯„åœåœ¨é›¶åˆ°åäº”ä¹‹é–“ï¼Œæ•¸å­—èˆ‡æ•¸å­—é–“ç”¨ç©ºæ ¼åˆ†é–‹ã€‚
### æ–¹æ³•:
```c++
#include<iostream>
#include<string>
/*
*Enter the numbers from 0 to 15
*The output will be converted to hexadecimal
*/
int main()
{
	const std::string hexdigits = "0123456789ABCDEF"; //possible hex digits
	std::string result;
	decltype(hexdigits.size()) index; //std::string::size_type index;
	//é€šå¸¸å°±æ˜¯unsigned
	std::cout << "Please enter a series of numbers between 0 and 15, separated by spaces. Hit ENTER when finished: " << std::endl;
	while (std::cin >> index) //read the input
	{
		if (index < hexdigits.size()) // check if the input is valid or not
		{
			result  = result + " " + hexdigits[index];
		}
		else
		{
			std::cout << "The input is invalid." << std::endl;
			return -1;
		}
	}
	std::cout << "The hex number is: " << result << std::endl;	
	return 0;
}
```
## 9 Vector:
### Vectoræ˜¯ä¸€å€‹è£æ»¿ç‰©ä»¶(object)çš„é›†åˆï¼Œå…¶ä¸­æ¯å€‹ç‰©ä»¶éƒ½æœ‰ç›¸åŒçš„å‹åˆ¥ï¼Œé€™è£¡æˆ‘å€‘ç›´æ¥é€éç·´ç¿’é¡Œä¾†ç†è§£ã€‚
## ç·´ç¿’é¡Œ6
>è¼¸å…¥ä¸€å€‹é›†åˆï¼Œç¯„åœåœ¨0~9ï¼Œä¸”æœ€å¤šåªèƒ½æœ‰ä¹å€‹æ•¸å­—ï¼Œæ±‚å…¶æ‰€æœ‰å…ƒç´ çš„å¹³æ–¹ã€‚
### æ–¹æ³•:
```c++
#include<iostream>
#include<string>
#include<vector>
int main()
{
	std::vector<int> v(9);
	int index = 0;
	while (std::cin >> v[index] && index < v.size()) //0-1 1-2 2-3 3-4 4-5 5-6 6-7 7-8 8-9
	{
		if (v[index] <= 9) //check if the input is valid or not
		{
			if (index != 8) //limit the input to 9
			{
				++index;
			}
			else
			{
				break;
			}
		}
		else
		{
			std::cout << "Invalid input!" << std::endl;
			return -1;
		}
	}	
	for (auto &i : v)
	{
		i *= i;
		std::cout << i << " ";
	}
	std::cout << std::endl;
	return 0;
}
```
## ç·´ç¿’é¡Œ7
>è¼¸å…¥ä¸€å€‹é›†åˆï¼Œå…§å®¹ç‰©æ˜¯åˆ†æ•¸ç¯„åœåœ¨0~100ï¼ŒåŒæ™‚æˆ‘å€‘æ ¹æ“š0-9/10-19/.../90-99/100çš„æ–¹å¼å°‡å…¶åˆ†ç‚º11å€‹å±¤æ¬¡ã€‚ç›®æ¨™æ˜¯è¨ˆç®—å‡ºå„å€‹å±¤æ¬¡çš„äººæ•¸ï¼ŒåŒæ™‚å‘Šè¨´æˆ‘å€‘ç¸½å…±æœ‰å¤šå°‘å­¸ç”Ÿã€‚
### æ–¹æ³•:
```c++
#include<iostream>
#include<string>
#include<vector>
//Enter the grades from 0 to 100 when you done press Ctrl+Z
int main()
{
	std::vector<unsigned> grades; //in order to store the grade
	unsigned grade; 
	std::vector<unsigned> level(11); //in order to store the number of students in each level

	while (std::cin >> grade) //read the grade(input)
	{
		if (grade <= 100)
		{
			grades.push_back(grade);
		}
		else
		{
			std::cout << "Invalid input!" << std::endl;
			return -1;
		}
	}
	for (auto recorded_grade : grades) //take the grade from grades
	{
		++level[recorded_grade / 10]; //e.g. 89/10 = 8.9 so the grade will be stored in level[8]
	}
	
	int level_index = 1;
	for (auto i : level) //check how many students in each level from level 1 to level 11
	{
		std::cout << "Level " << level_index << ": " << i << " student(s)." << std::endl;
		++level_index;
	}
	std::cout << "Total students: " << grades.size() << std::endl;
	return 0;
}
```
## 10 è¿­ä»£å™¨(Iterator):
### 1. åœ¨å¾ˆå¤šæ™‚å€™ï¼Œæˆ‘å€‘ä¸¦æ²’æœ‰è¾¦æ³•åƒå°å¾…stringåˆæˆ–è€…æ˜¯vectoré‚£æ¨£ï¼Œä½¿ç”¨indexä¾†å­˜å–æˆ‘å€‘æƒ³è¦çš„å…ƒç´ ï¼Œåœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œæˆ‘å€‘å°±æœƒä½¿ç”¨è¿­ä»£å™¨ï¼Œå¦‚ä¸‹:
```c++
#include<iostream>
#include<string>
#include<vector>
int main()
{
	std::string test_string("Hello, World!");
	for (auto convert_s = test_string.begin(); convert_s != test_string.end(); ++convert_s)
	{
		*convert_s = toupper(*convert_s);
	}
	std::cout << test_string << std::endl;
	return 0;
}
```
```c++
for (auto convert_s = test_string.begin(); convert_s != test_string.end(); ++convert_s)
```
### ç¨‹å¼ç¢¼è§£é‡‹:convert_såˆå§‹åŒ–ç‚ºtest_stringçš„ç¬¬ä¸€å€‹å…ƒç´ ï¼Œä¸”å‹åˆ¥ç”±ç·¨è­¯å™¨åˆ¤æ–·ï¼Œä¸æ–·å‘å¾Œç§»å‹•ï¼Œç›´åˆ°ç¢°åˆ°çµå°¾(æœ€å¾Œä¸€å€‹å…ƒç´ çš„ä¸‹ä¸€å€‹ä½ç½®ï¼Œæ˜¯ä¸å­˜åœ¨çš„)ã€‚
```c++
*convert_s = toupper(*convert_s);
```
### ç¨‹å¼ç¢¼è§£é‡‹:å°‡convert_sæ‰€æŒ‡å‘ä½å€çš„å­—æ¯åšå¤§å¯«è½‰æ›ï¼Œç„¶å¾Œæ›¿æ›æ‰ã€‚
### 2. è¿­ä»£å™¨çš„å®šç¾©æ–¹å¼:
```c++
std::vector<int>::iterator it;
std::string::iterator it2;
std::vector<int>::const_iterator it3;
std::vector<int> v;
auto it4 = v.cbegin(); //type:std::vector<int>::const_iterator
```
## ç·´ç¿’é¡Œ8
>è¼¸å…¥ä¹å€‹æ•¸å­—ï¼Œä»¥åŠè¦å°‹æ‰¾çš„æ•¸å­—ï¼ŒäºŒåˆ†æœå°‹æ³•çš„æ‡‰ç”¨ã€‚
### æ–¹æ³•:
```c++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
int main()
{
	std::vector<double> v(9); //sorted array
	double target = 0; //target value
	double index = 0;
	auto begin = v.begin(), end = v.end();
	auto mid = begin + (end - begin) / 2;
	std::cout << "Please enter a sorted array: " << std::endl;
	while (std::cin >> v[index])
	{
		
		if (index != 8)
		{
			++index; //keep tracking the index and recording the input
		}
		else //after the input is done
		{
			std::cout << "Please enter the target value: " << std::endl;
			std::cin >> target;
			std::sort(v.begin(), v.end()); //sort the array
			break;
		}
	}
	while (mid != end && *mid != target) //binary search
	{
		if (*mid < target) //check if the mid value is less than the target value or not
		{
			begin = mid + 1; //from mid to end(right side)
		}
		else
		{
			end = mid; //from begin to mid(left side)
		}
		mid = begin + (end - begin) / 2;
	}
	if (mid != end) //check if the mid value is not equal to the end value since if mid is equal to end, it means the target value is not in the array
	{
		std::cout << "The target value " << target << " is at index " << mid - v.begin() << std::endl;
		return 0;
	}
	else
	{
		std::cout << "The target value " << target << " is not in the array." << std::endl;
		return -1;
	}
}
```
## 11 é™£åˆ—(array):
### 1. èˆ‡vectorä¸åŒï¼Œé™£åˆ—æ˜¯æœ‰å›ºå®šå¤§å°çš„ï¼Œå®šç¾©æ–¹å¼å¦‚ä¸‹:
```c++
unsigned cnt = 42; //not a constant expression
constexpr unsigned sz = 42; //a constant expression
int arr[10]; //an array with 10 int
int *parr[sz]; //an array with 42 int pointers
string bad[cnt]; //wrong cnt is not a constant expression
```
### 2. é™£åˆ—çš„å¤§å°è¢«æŒ‡å®šå®Œå¾Œå°±ä¸èƒ½æ›´æ”¹äº†ï¼Œå…¶å…§éƒ¨æ‰€å«çš„å…ƒç´ æ•¸é‡ä¹Ÿä¸èƒ½å¤§éå…¶å°ºå¯¸å¤§å°ï¼Œå¦‚ä¸‹:
```c++
const unsigned sz = 3;
int a1[sz] = {0, 1, 2}; //correct
int a1[sz] = {}; //correct
int a2[5] = {0, 1, 2}; //a = {0, 1, 2, 0, 0}
int a3[2] = {0, 1, 2}; //error 3 > 2
```
### 3. å­—å…ƒé™£åˆ—æ˜¯ç‰¹æ®Šçš„ï¼Œå› ç‚ºå­—ä¸²æœ€å¾Œæœƒå†åŠ ä¸Šä¸€å€‹nullåšçµå°¾:
```c++
char a4[] = "C++"; //C++\0
char a5[6] = "Dainel"; //error no space for null
```
### 4. é™£åˆ—æ˜¯ç„¡æ³•æŒ‡å®š(æ‹·è²)çš„:
```c++
int a[] = {0, 1, 2};
int a2[] = a; //error
a2 = a; //error
```
### 5. é™£åˆ—ä¹Ÿæ˜¯ä¸€ç¨®ç‰©ä»¶ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æŒ‡æ¨™ï¼Œä½†è¦è¨˜å¾—é™£åˆ—æ²’è¾¦æ³•ç”±åƒè€ƒ(reference)çµ„æˆ:
```c++
int *ptrs[10]; //an array with 10 int pointers
int &refs[10]; //error no reference
int (*parray)[10] = &arr; //point to an array with 10 int
int (&arrRef)[10] = arr; //bind to an array with 10 int
```
### 6. ç•¶æˆ‘å€‘ä½¿ç”¨ä¸€å€‹é™£åˆ—æ™‚ï¼Œç·¨è­¯å™¨é€šå¸¸æœƒå°‡å®ƒç•¶æˆä¸€å€‹æŒ‡æ¨™ä¾†ç”¨:
```c++
string nums[] = {"one", "two", "three"};
string *p = &nums[0]; //one
string *p2 = nums; //*p2 = nums[0]
```
```c++
int ia[] = {0, 1, 2, 3, 5, 6};
auto ia2(ia); //a pointer point to ia[0]
```
### 7. æŠŠæŒ‡æ¨™ç•¶æˆè¿­ä»£å™¨:
```c++
int ia[] = {0, 1, 2, 3, 5, 6};
int *p = ia; //ia[0]
++p; //ia[1]
```
### 8. begin and end:
```c++
int ia[] = {0, 1, 2, 3, 5, 6};
int *b = begin(ia);
int *e = end(ia);
```
### é€šéä¸Šé¢é€™å€‹æ–¹æ³•ï¼Œæˆ‘å€‘å°±å¯ä»¥å°å‡ºé™£åˆ—ä¸­çš„æ‰€æœ‰å…ƒç´ :
```c++
#include<iostream>
#include<vector>
#include<string>
int main()
{
	int ia[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //array
	int *beg = std::begin(ia); //pointer to the first element of the array
	int *last = std::end(ia); //pointer to the last element of the array
	while (beg < last) //print the array until the last element
	{
		std::cout << *beg << std::endl;
		++beg;
	}
	return 0;
}
```
### 9. å­—å…ƒå­—ä¸²å‡½å¼:
```c++
strlen(p); //the length of p, null is not included
strcmp(p1, p2); //compare p1, p2
strcat(p1, p2); //concatenate p1 and p2
strcpy(p1, p2); //p1 = p2
```
### 10. ç”¨é™£åˆ—ä¾†åˆå§‹åŒ–vecotr:
```c++
int int_arr[] = {0, 1, 2, 3, 4, 5};
std::vector<int> ivec(std::begin(int_arr), std::end(int_arr)) //{0, 1, 2, 3, 4, 5};
std::vector<int> subvec(int_arr + 1, int_arr + 4) //{1, 2, 3};
```
## 12 å¤šç¶­é™£åˆ—:
### 1. åœ¨C++ä¸­ä¸¦æ²’æœ‰æ‰€è¬‚çš„å¤šç¶­é™£åˆ—ï¼Œæ‰€è¬‚å¤šç¶­é™£åˆ—ï¼Œå…¶å¯¦å°±æ˜¯ç”±é™£åˆ—æ§‹æˆçš„é™£åˆ—ã€‚
```c++
int a[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}}
```
```c++
#include<iostream>
#include<vector>
#include<string>
int main()
{
	int ia[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} }; //an 3x4 array
	for (const auto &row : ia) //{0-1-2-3}/{4-5-6-7}/{8-9-10-11}
	{
		for (auto &col : row) //
		{
			std::cout << col << std::endl;
		}
	}
	return 0;
}
```
```c++
#include<iostream>
#include<vector>
#include<string>
int main()
{
	int ia[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} }; //an 3x4 array
	for (auto p = ia; p != std::end(ia); ++p) //p point to ia
	{
		for (auto q = *p; q != std::end(*p); ++q) q point to p
		{
			std::cout << *q << std::endl;
		}
	}
	return 0;
}
```
### å„ªåŒ–ï¼Œæé«˜ç¨‹å¼å¯è®€æ€§:
```c++
#include<iostream>
#include<vector>
#include<string>
int main()
{
	int ia[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} }; //an 3x4 array
	using int_array = int [4];
	for (int_array *p = std::begin(ia); p != std::end(ia); ++p)
	{
		for (int *q = std::begin(*p); q != std::end(*p); ++q)
		{
			std::cout << *q << std::endl;
		}
	}
	return 0;
}
```

## 13 é‹ç®—å¼(Expression):
### 1. ä¼°ç®—é †åºã€å„ªå…ˆåºï¼Œçµåˆæ€§:é‹ç®—å…ƒçš„çš„ä¼°ç®—ç¨ç«‹æ–¼å„ªå…ˆåºå’Œçµåˆæ€§ï¼Œå¦‚ä¸‹:
### f() + g() * h() + j() çµåˆæ€§æœƒä¿è­‰g()*h() ç„¶å¾Œå†åŠ åˆ°f()ï¼Œæœ€å¾Œå†èˆ‡j()ç›¸åŠ ã€‚
### è‡³æ–¼å‡½å¼çš„å‘¼å«é †åºï¼Œåªè¦å®ƒå€‘éƒ½æ˜¯ç¨ç«‹çš„ï¼Œå‰‡ä¸¦ä¸é‡è¦ã€‚
### 2. å¤šç”¨æ‹¬è™Ÿä¾†çµ„åˆï¼Œå°±ä¸æœƒæœ‰å•é¡Œäº†ã€‚
### 3. å¦‚æœä½ æ¾³æ›´æ”¹æŸå€‹é‹ç®—å…ƒçš„å€¼ï¼Œé‚£å°±åˆ¥åœ¨åŒä¸€å€‹é‹ç®—å¼ä¸­ä½¿ç”¨é‚£å€‹é‹ç®—å…ƒï¼Œå¦‚ä¸‹:
```c++
int i = 0;
std::cout << i << ++i << std::endl; //error
```
### 4. ç®—è¡“é‹ç®—å­ï¼Œå¦‚åœ–:
![Expression](https://github.com/littleyu0820/Interview_Leetode/blob/main/PitcturesForLearning/expression.png)
### 5. boolçš„å€¼ä¸æ‡‰è©²ç”¨æ–¼è¨ˆç®—:
```c++
bool b = true;
bool b2 = -b; //b2é‚„æ˜¯true å› ç‚ºä»–è¿”å›-1ï¼Œåªè¦ä¸æ˜¯é›¶ï¼Œéƒ½æ˜¯true
```
### 5. å–é¤˜æ•¸æ™‚(a % b)ï¼Œaè·Ÿbéƒ½å¿…é ˆç‚ºæ•´æ•¸ã€‚
### 6. å–é¤˜æ•¸æ™‚(m & n)ï¼Œå¾—åˆ°çµæœçš„æ­£è² è™Ÿæ˜¯è·Ÿè‘—mçš„ã€‚
```c++
-21 % 8 = -5 (-/-)
21 % -5 = 1 (+/+)
```
### 7. ç®—æ•¸é‹ç®—å¼(a+b)ï¼Œåªèƒ½æ”¾åœ¨å³é‚Šï¼Œæ˜¯rvaluesã€‚
## ç·´ç¿’é¡Œ9
### æ–¹æ³•:
```c++
#include<iostream>
int main()
{
	std::cout << "This program will stop when we meet the first negative number." << std::endl;
	std::cout << "Please enter some numbers(Max:10): " << std::endl;
	int i[10], index = 0, max_index = 9;
	while (index <= max_index)
	{
		std::cin >> i[index];
		++index;
	}

	auto pbegin = std::begin(i);
	while (pbegin != std::end(i) && *pbegin >= 0)
	{
		std::cout << *pbegin++ << std::endl; //will print --pbegin
	}

	std::cout << "And the first negative number is: " << *pbegin << std::endl;
	return 0;
}
```
### 8. æ¢ä»¶é‹ç®—å­:
### condtition ? expression1 : expression2ï¼Œç•¶conditionæˆç«‹æ™‚ï¼ŒåŸ·è¡Œexpression1ï¼Œå¦å‰‡å°±åŸ·è¡Œexpression2ã€‚
### 9. æˆå“¡å­˜å–é‹ç®—å­:
```c++
std::string s1 = "a string";
std::string *p = &s1;
auto n = s1.size(); //å®šç¾©å‹åˆ¥
n = (*p).size(); 
n = p->size(); //èˆ‡ä¸Šå¼ä¸€æ¨£
std::cout << n << std::endl;
```
## ç·´ç¿’é¡Œ10
### æ–¹æ³•:
```c++
/*
* è¼¸å…¥ä¸€äº›æ•¸å­—(æœ€å¤š10å€‹)
* è¼¸å‡ºçµæœç‚ºå°‡å…¶ä¸­æ‰€æœ‰å¥‡æ•¸æ•¸å­—åšå¹³æ–¹
* ç”¨vectorå¯¦ç¾
*/
#include<iostream>
#include<vector>
#include<iterator>
int main()
{
	std::vector<int> nums(10);
	for (int index = 0; index < nums.size(); ++index)
	{
		std::cin >> nums[index];
	}
	for (auto num = nums.begin(); num != nums.end(); ++num)
	{	
		std::cout << ((*num % 2 != 0) ? ((*num) * (*num)) : *num) << std::endl;
	}
	return 0;
}
```
### 10. å¼·åˆ¶å‹åˆ¥è½‰æ›ï¼Œå…±åˆ†å››ç¨®:static_castã€dynamic_casã€const_castï¼Œä»¥åŠreinterpret_castã€‚

## 14 è¿°å¥(statement):
### 1. åœ¨C++ä¸­å¤§éƒ¨åˆ†çš„è¿°å¥éƒ½æ˜¯ä»¥ä¸€å€‹";"ä½œç‚ºçµå°¾ã€‚
### 2. è¿°å¥åˆåˆ†ç‚ºå¹¾ç¨®ï¼Œé¦–å…ˆæåˆ°çš„æ˜¯"é‹ç®—å¼è¿°å¥":
```c++
ival + 5; //ç„¡ç”¨ä½†æ­£ç¢º
cout << val; /æœ‰ç”¨ä¸”æ­£ç¢º
```
### 3. "nullè¿°å¥":
```c++
//æŒçºŒè®€å–è¼¸å…¥ï¼Œç›´åˆ°ç¢°åˆ°soughtï¼Œåˆæˆ–è€…æª”æ¡ˆçµå°¾æ‰é ‚åª
while (std::cin >> s && s != sought)
	;
```
### 4. "è¤‡åˆè¿°å¥"ï¼Œé€šå¸¸æˆ‘å€‘ä¹Ÿå°‡å®ƒç¨±ç‚º"å€å¡Š"ï¼Œæ˜¯ç”±å…©å€‹å¤§æ‹¬è™Ÿæ‰€åŒ…åœèµ·ä¾†çš„:
```c++
while(val <= 10}
{
	sum += val;
	++val;
}
```
### è¨»è¨˜:åœ¨å€å¡Šå…§å®šç¾©çš„è®Šæ•¸åœ¨å¤–é¢ä¸èƒ½ç”¨ã€‚
### 5. ifè¿°å¥:
## ç·´ç¿’é¡Œ11
### æ–¹æ³•:
```c++
#include<iostream>
#include<string>
#include<vector>
#include<iterator>
/*
* A program for defining the grades for students
* The level are A++(100) A+/A-(90~99) B+/B-(80~89) C+/C-(70~79) D+/D-(60~69) F+/F-(0~59)
*/
int main()
{
	std::string level[6] = {"Failed", "D", "C", "B", "A", "A++"}; //6 levels
	unsigned grades[10] = {}, grades_in = 0, counter = 0; //Max students:10
	
	while (std::cin >> grades_in)
	{
		grades[counter] = grades_in;
		++counter;
		if (counter == 10)
		{
			std::cout << "Already 10 students." << std::endl;
			break;
		}
	}
	std::string levels;
	for (unsigned &identify_grades : grades)
	{
		if (identify_grades < 60)
		{
			std::cout << identify_grades << ": " << level[0] << std::endl;
		}
		else
		{
			levels = level[(identify_grades - 50) / 10];
			if (identify_grades % 10 > 7)
			{
				levels += "+";
			}
			else if(identify_grades % 10 < 3 && identify_grades != 100)
			{
				levels += "-";
			}
			else
			{
				;
			}
			std::cout << identify_grades << ": " << levels << std::endl;
		}
	}
	return 0;
}
```
### 6. switchè¿°å¥æä¾›æ•¸å€‹å›ºå®šçš„æ›¿ä»£æ–¹æ¡ˆè®“æˆ‘å€‘æŒ‘é¸ã€‚
### åœ¨ä½¿ç”¨switch caseæ™‚æœ€å¥½éƒ½åŠ ä¸Š"break;"ï¼Œå› ç‚ºä¸€ä½†ç¨‹å¼åŒ¹é…åˆ°äº†æ­£ç¢ºçš„caseï¼Œå¦‚æœæˆ‘å€‘æ²’æœ‰æ‰“ç ´ï¼Œå®ƒå°‡æœƒç¹¼çºŒå‘ä¸‹åŸ·è¡Œï¼Œè€Œä¸æ˜¯è·³å‡ºswitchã€‚
## ç·´ç¿’é¡Œ12
### æ–¹æ³•:
```c++
#include<iostream>
#include<string>
#include<vector>
#include<iterator>
/*
* A program for defining the grades for students
* The level are A++(100) A+/A-(90~99) B+/B-(80~89) C+/C-(70~79) D+/D-(60~69) F+/F-(0~59)
*/
int main()
{
	std::string level[6] = {"Failed", "D", "C", "B", "A", "A++"}; //6 levels
	unsigned grades[10] = {}, grades_in = 0, counter = 0; //Max students:10	
	while (std::cin >> grades_in)
	{
		grades[counter] = grades_in;
		++counter;
		if (counter == 10)
		{
			std::cout << "Already 10 students." << std::endl;
			break;
		}
		else if(grades_in > 100)
		{
			std::cerr << "Invalid input." << std::endl;
			break;
		}
	}	
	std::string levels;
	for (unsigned &identify_grades : grades)
	{
		if (identify_grades < 60)
		{
			std::cout << identify_grades << ": " << level[0]  << " Please study hard!" << std::endl;
		}
		else
		{
			levels = level[(identify_grades - 50) / 10];

			if (identify_grades % 10 > 7)
			{
				levels += "+";
			}
			else if(identify_grades % 10 < 3 && identify_grades != 100)
			{
				levels += "-";
			}
			else
			{
				;
			}
			switch (identify_grades / 10)
			{
				case 10:
				case 9:
					std::cout << identify_grades << ": " << levels << " You're excellent!" << std::endl;
					break;
				case 8:
					std::cout << identify_grades << ": " << levels << " You're nice!" << std::endl;
					break;
				case 7:
					std::cout << identify_grades << ": " << levels << " You're good!" << std::endl;
					break;
				case 6:
					std::cout << identify_grades << ": " << levels << " You can be more better!" << std::endl;
					break;
			}
		}
	}
	return 0;
}
```
### è¨»è¨˜:switchè£¡é¢ä¸èƒ½åˆå§‹åŒ–ï¼Œä½†å¦‚æœä½ æ‹¬è™Ÿèµ·ä¾†å°±å¯ä»¥ï¼Œå› ç‚ºæŠŠå®ƒé™å®šåœ¨å€å¡Šå…§äº†ï¼Œèˆ‡å¤–é¢ç„¡é—œã€‚
### 7. do whileè¿°å¥:
## ç·´ç¿’é¡Œ13
```c++
/*é€™å€‹ç¨‹å¼å¯ä»¥è®“æˆ‘å€‘çµ±è¨ˆæˆç¸¾*/
#include<iostream>
#include<string>
#include<vector>
int main()
{
	std::vector<unsigned> grades;
	std::string levels[6] = {"Failed", "D", "C", "B", "A", "A++"};
	std::string YesorNo;
	int grade_in = 0, stduents = 0, counter = 0;
	std::cout << "Do you want to start?(Yes or No)" << std::endl;
	std::cin >> YesorNo;
	if (YesorNo == "Yes" || YesorNo == "yes")
	{
		std::cout << "How many students do you need to enter?" << std::endl;
		std::cin >> stduents;
		do
		{
			std::cout << "Please enter the grades." << std::endl;
			std::cin >> grade_in;
			grades.push_back(grade_in);
			++counter;

		} while (counter < stduents);
	}
	else
	{
		std::cout << "Thanks for using." << std::endl;
		return 0;
	}
	std::string level;
	for (unsigned &identify_grades : grades) //ç¯„åœfor(auto beg = v.begin(); beg != v.end(), ++beg) auto &r = *beg;
	{
		if (identify_grades < 60)
		{
			std::cout << identify_grades << ": " << levels[0] << " Please study hard!" << std::endl;
		}
		else
		{
			level = levels[(identify_grades - 50) / 10];

			if (identify_grades % 10 > 7)
			{
				level += "+";
			}
			else if (identify_grades % 10 < 3 && identify_grades != 100)
			{
				level += "-";
			}
			else
			{
				;
			}
			switch (identify_grades / 10)
			{
			case 10:
			case 9:
				std::cout << identify_grades << ": " << level << " You're excellent!" << std::endl;
				break;
			case 8:
				std::cout << identify_grades << ": " << level << " You're nice!" << std::endl;
				break;
			case 7:
				std::cout << identify_grades << ": " << level << " You're good!" << std::endl;
				break;
			case 6:
				std::cout << identify_grades << ": " << level << " You can be more better!" << std::endl;
				break;
			}
		}
	}
	return 0;	
}
```
### 8. continueè¿°å¥ï¼Œå¼·åˆ¶é–‹å§‹ä¸‹ä¸€è¼ªè¿´åœˆã€‚
### 9 gotoè¿°å¥ï¼Œè·³è½‰åˆ°ä¸€å€‹å¸¶æœ‰æ¨™ç±¤çš„è¿°å¥ï¼Œä¸¦ä¸”å‘ä¸‹åŸ·è¡Œã€‚
## 15 ä¾‹å¤–(ç•°å¸¸)è™•ç†:
### throwé‹ç®—å¼:
```c++
throw runtime_error("An error."); //stop
```
### tryé‹ç®—å¼:
```c++
try
{}
catch(runtime_error err)
{
std::cout << err.what() << std::endl;
}
```
## ç¶œåˆç·´ç¿’
>è¨­è¨ˆä¸€å€‹æˆç¸¾çµ±è¨ˆç¨‹å¼ï¼Œèƒ½å¤ è®“è€å¸«æ±ºå®šæ˜¯å¦é–‹å§‹ï¼Œå…§å®¹åŒ…å«å¯ä»¥è¼¸å…¥ç¸½äººæ•¸ï¼Œèƒ½å¤ å°‡æ¯å€‹å­¸ç”Ÿçš„åˆ†æ•¸ä»¥A++ A+/A/A- B+/B/B- C+/C/C- D+/D/D- ä»¥åŠFä¾†å€åˆ†é–‹ä¾†ï¼Œæœ€å¾Œåœ¨çµ¦ä¸Šå›ºå®šçš„è©•èªï¼Œè«‹è€ƒæ…®å¦‚æœè¼¸å…¥è² æ•¸ç¨‹å¼è©²å¦‚ä½•ä¿®æ­£ã€‚

>Solution:
```c++
/*
* é€™å€‹ç¨‹å¼å¯ä»¥è®“æˆ‘å€‘çµ±è¨ˆæˆç¸¾
* åŒæ™‚æ‡‰ç”¨åˆ°
* do while
* for
* vector
* continue
* goto
* try/throw runrime_error
*/
#include<iostream>
#include<string>
#include<vector>
int main()
{
	std::vector<int> grades; //store grades
	std::string levels[6] = {"Failed", "D", "C", "B", "A", "A++"}; //6levels
	std::string YesorNo; //start or not start
	int grade_in = 0, stduents = 0, counter = 0;

	std::cout << "Do you want to start?(Yes or No)" << std::endl;
	std::cin >> YesorNo;
	if (YesorNo == "Yes" || YesorNo == "yes") //start or not start
	{
		begin: //if we choose start from here
			std::cout << "How many students do you need to enter?" << std::endl;
			std::cin >> stduents;
		try //try error
		{
			if (stduents <= 0)
			{
				throw std::runtime_error("Please eneter a positive number.");
			}
		}
		catch (std::runtime_error err) //if error
		{
			std::cout << err.what() << std::endl;
			goto begin;
		}
		do //start to enter
		{
			std::cout << "Please enter the grades." << std::endl;
			std::cin >> grade_in;
			if (grade_in < 0) //if negative numbers
			{
				std::cout << "Please eneter a number greater than 0." << std::endl;
				continue;
			}
			else
			{
				grades.push_back(grade_in); //store the grades into the vector
				++counter;
			}

		} while (counter < stduents); //stop when the grades are enough
	}
	else
	{
		std::cout << "Thanks for using." << std::endl;
		return 0;
	}
	std::string level;
	for (int &identify_grades : grades) //start to group the students
	{
		if (identify_grades < 60) //failed
		{
			std::cout << identify_grades << ": " << levels[0] << " Please study hard!" << std::endl;
		}
		else
		{
			level = levels[(identify_grades - 50) / 10]; //except for F we still have 5 levels from levels[1] to levels[5]

			if (identify_grades % 10 > 7) //identify better/normal/so-so
			{
				level += "+";
			}
			else if (identify_grades % 10 < 3 && identify_grades != 100) //except for 100
			{
				level += "-";
			}
			else
			{
				;
			}
			switch (identify_grades / 10) //give each levels a comment
			{
			case 10:
			case 9:
				std::cout << identify_grades << ": " << level << " You're excellent!" << std::endl;
				break;
			case 8:
				std::cout << identify_grades << ": " << level << " You're nice!" << std::endl;
				break;
			case 7:
				std::cout << identify_grades << ": " << level << " You're good!" << std::endl;
				break;
			case 6:
				std::cout << identify_grades << ": " << level << " You can be more better!" << std::endl;
				break;
			}
		}
	}
	return 0;
}
```

## 15 å‡½å¼(function):
### 1. ä¸€å€‹å‡½å¼çš„å®šç¾©é€šå¸¸ç”±ä¸€å€‹å›å‚³ã€ä¸€å€‹åç¨±ï¼Œä»¥åŠä¸€ä¸²åƒæ•¸(ç¨‹å¼å…§å®¹)æ‰€çµ„æˆçš„ã€‚
```c++
#include<iostream>
#include<vector>
#include<string>
int fact(int val)
{
	int ret = 1;
	while (val > 1)
	{
		ret *= val--; //5 4 3 2 1
	}
	return ret;
}
int main()
{
	int val = 4;
	int restult = fact(val);
	std::cout << restult << std::endl;
	return 0;
}
```
### 2. ä¸€å€‹å‡½å¼çš„åŸ·è¡Œæœƒåœ¨é‡åˆ°ä¸€å€‹returnæ™‚çµæŸã€‚
### 3. å¤§å¤šæ•¸çš„å‹åˆ¥éƒ½å¯ä»¥é€²è¡Œå›å‚³ï¼Œä½†è¦è¨˜å¾—æˆ‘å€‘ä¸èƒ½å›å‚³å‡½å¼è·Ÿé™£åˆ—ã€‚
### 4. åœ¨C++ä¸­ï¼Œåç¨±å…·æœ‰ç¯„ç–‡(scope)ï¼Œç°¡å–®é»ä¾†è¬›å°±æ˜¯æœ‰ç¯„åœçš„ï¼Œå…·æœ‰å€åŸŸæ€§çš„ã€‚
### 5. ç‰©ä»¶å…·æœ‰ç”Ÿå‘½é€±æœŸ(lifetimes)ã€‚
### æ‰€è¬‚ç”Ÿå‘½é€±æœŸæŒ‡çš„æ˜¯è©²ç‰©ä»¶è¢«åŸ·è¡Œæ™‚æ‰€å­˜åœ¨çš„æ™‚é–“ã€‚
### 6. ç‰©ä»¶åˆå¯åˆ†ç‚º"è‡ªå‹•ç‰©ä»¶"(Automatic Objects)è·Ÿ"å€åŸŸç‰©ä»¶"(Static Objects)ã€‚
### è‡ªå‹•ç‰©ä»¶æ³›æŒ‡çš„æ˜¯è©²ç‰©ä»¶åªæœ‰åœ¨å‡½å¼åŸ·è¡Œæ™‚å­˜åœ¨ï¼ŒçµæŸå¾Œå°±æ¶ˆå¤±äº†ã€‚
### å€åŸŸç‰©ä»¶æ³›æŒ‡çš„æ˜¯è©²ç‰©ä»¶æœƒåœ¨å‡½å¼åŸ·è¡Œå¾Œå°±ä¸€ç›´å­˜åœ¨ï¼Œç›´åˆ°æ•´å€‹ç¨‹å¼å®Œå…¨çµæŸæ‰æœƒæ¶ˆå¤±ã€‚
```c++
#include<iostream>
#include<vector>
#include<string>
int counter(int);
int main()
{
	int val = 5;
	while (val > 0)
	{
		std::cout << counter(val--) << std::endl;
	}
	return 0;
}
int counter(int val)
{
	//int ctr = 0; //will re-initialize when the function is called
	static int ctr = 0; //only initialize once despite the function is called every times
	if (val > 0)
	{
		++ctr;
	}
	return ctr;
}
```
### 7. å‡½å¼è·Ÿè®Šæ•¸ä¸€æ¨£ï¼Œè¦ä½¿ç”¨å‰å¿…é ˆå…ˆå®£å‘Šã€‚
### 8. å¯ä»¥é€šéæŒ‡æ¨™ä¾†æ”¹è®Šç‰©ä»¶çš„å€¼:
```c++
void reset_pointer(int *p)
{
	*p = 50; //will re-initialize
	//p = 50;
}
```
### ç¨‹å¼ç¢¼è§£é‡‹:å®šç¾©æŒ‡æ¨™æ”¹è®Šç‰©ä»¶çš„å‡½å¼
```c++
reset_pointer(&test_nums);
```
### ç¨‹å¼ç¢¼è§£é‡‹:å‘¼å«è©²å‡½å¼
### 8. å¯ä»¥é€šéåƒè€ƒä¾†æ”¹è®Šç‰©ä»¶çš„å€¼:
```c++
void references_reset(int &val)
{
	val = 100;
}
```
```c++
int main()
{
	int test_nums = 0;
	references_reset(test_nums);
	std::cout << test_nums << std::endl;
}
```
### 9. å¦‚æœçœŸçš„è¦æ”¹è®Šç‰©ä»¶ï¼Œæœ€å¥½çš„æ–¹å¼æ˜¯ä½¿ç”¨åƒè€ƒã€‚å› ç‚ºåƒè€ƒæ˜¯ç›´æ¥æ”¹è®Šè©²ç‰©ä»¶ï¼Œè€Œéé€šé"æ‹·è²"çš„æ–¹å¼ï¼Œæ‹·è²çš„è©±æˆ‘å€‘çš„ä½¿ç”¨æ•ˆç‡æœƒå¤§å¹…é™ä½ã€‚
### 10. å¦‚æœæˆ‘å€‘ä¸å¸Œæœ›ä¿®æ”¹ç‰©ä»¶ï¼Œé‚£å°±è¨˜å¾—ä½¿ç”¨constï¼š
```c++
int test_const(const int val)
{
	///val = 50; //we cant modify a constant
	return val;
}
```
```c++
//ä½¿ç”¨constä¾†å›ºå®šè®Šæ•¸
int main()
{
	int test_nums = 10;
	int result = test_const(test_nums);
	std::cout << result << std::endl;
	return 0;
}
```
### 11. ä¸€å€‹å‡½å¼åªèƒ½å›å‚³ä¸€å€‹å€¼ï¼Œä½†æˆ‘å€‘å¯ä»¥é€šéåƒè€ƒçš„æ–¹å¼ï¼Œä¾†å›å‚³å¤šå€‹çµæœã€‚
## ç·´ç¿’é¡Œ14
```c++
#include<iostream>
#include<string>
#include<vector>
/*
* è¨­è¨ˆä¸€å€‹å¯ä»¥åœ¨å­—ä¸²æ‰¾å‡ºç‰¹å®šå­—æ¯çš„å‡½å¼ï¼Œå¾—åˆ°çš„çµæœå¿…é ˆåŒ…å«:
* è©²å­—æ¯å‡ºç¾äº†å¹¾æ¬¡ä»¥åŠç¬¬ä¸€æ¬¡å‡ºç¾åœ¨å“ªè£¡ï¼Œä¸¦ä¸”å¯ä»¥è‡ªè¨‚æƒ³è¦çš„å­—ä¸²èˆ‡å­—æ¯
* å¦‚æœæ²’æœ‰æ‰¾åˆ°è©²å­—æ¯ï¼Œè¦è®“ä½¿ç”¨è€…å¯ä»¥é¸æ“‡æ˜¯å¦é‡æ–°é–‹å§‹
*/
std::string::size_type find_char(const std::string, const char,int&, bool&);
int main()
{
	begin:
	int occurs = 0;
	std::string test_s;
	char test_c;
	bool appearornot = false;
	std::cout << "Please enter the string: " << std::endl;
	getline(std::cin, test_s);
	std::cout << "Please enter the character you want to find: " << std::endl;
	std::cin >> test_c;
	auto result = find_char(test_s, test_c, occurs, appearornot);
	if (appearornot)
	{
		std::cout << "Character " << test_c << " occurs " << occurs << " times"
			<< " and appears(first) at index " << result << " in " << test_s << std::endl;
	}
	else
	{
		std::cout << "Sorry! The character you entered is not in the string: "
			<< test_s << std::endl;
		std::cout << "Do you want to try again?(Yes or No)" << std::endl;
		std::string YesOrNo;
		std::cin >> YesOrNo;
		if (YesOrNo == "Yes" || YesOrNo == "yes")
		{
			goto begin;
		}
		else
		{
			std::cout << "Thanks for using!" << std::endl;
			return 0;
		}
	}	
	return 0;
}
std::string::size_type find_char(const std::string s, const char c, int &occurs, bool &AppearOrNot)
{
	decltype(s.size()) first_time = 0;
	for (auto i = 0; i < s.size(); ++i)
	{
		if (s[i] == c)
		{
			if (!AppearOrNot)
			{
				AppearOrNot = true;
				first_time = i;
			}
			++occurs;
		}
	}
	return first_time;
}
```
### 12. æˆ‘å€‘é€šå¸¸å¼•ç”¨æŒ‡æ¨™åƒæ•¸ä¾†ç®¡ç†é™£åˆ—:
```c++
#include<iostream>
void pointer_practice(const int *beg, const int *end)
{
	while (*beg != *end)
	{
		std::cout << *beg++ << std::endl;
	}
}
```
```c++
int main()
{
	int test_arr[] = { 0, 1, 2, 3, 4, 5, 6 };
	int *beg = std::begin(test_arr); //an address
	int *end = std::end(test_arr); //an address
	pointer_practice(beg, end);
	return 0;
}
```
### 12. æˆ‘å€‘ä¹Ÿå¯ä»¥ä½¿ç”¨åƒè€ƒåƒæ•¸ä¾†ç®¡ç†é™£åˆ—:
```c++
#include<iostream>
void reference_practice(int (&arr)[10])
{
	for (auto run_arr : arr)
	{
		std::cout << run_arr << std::endl;
	}
}
```
```c++
int main()
{
	int test_arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	reference_practice(test_arr);
	return 0;
}
```
### è¨»è¨˜:ä½¿ç”¨é™£åˆ—æ™‚ä¸€å®šè¦å®£å‘Šå¤§å°ã€‚
### 13. å¸¶æœ‰ä¸å®šåƒæ•¸çš„å‡½å¼:
### æœ‰æ™‚å€™æˆ‘å€‘ä¸ç¢ºå®šåˆ°åº•è¦ä½¿ç”¨å¹¾å€‹åƒæ•¸ï¼Œå°±å¯ä»¥ä½¿ç”¨æ¨™æº–å‡½å¼åº«ä¸­çš„ï¼Œinitializer_list<type>:
### ç¬¬ä¸€ç¨®ç”¨æ³•:
```c++
#include<iostream>
#include<string>
#include<vector>
void print_string(std::initializer_list<std::string>); //kind of like vector
int main()
{
	std::initializer_list<std::string> test_s = { "Hello " , ", ""How ", "are ", "you ", "?"};
	print_string(test_s);
	return 0;
}
void print_string(std::initializer_list<std::string> ls)
{
	for (auto &s : ls)
	{
		std::cout << s;
	}
	std::cout << std::endl;
}
```
```c++
### ç¬¬äºŒç¨®ç”¨æ³•:
#include<iostream>
#include<string>
#include<vector>
void print_string(std::initializer_list<std::string>); //kind of like vector
int main()
{
	std::string test = "Hi";
	print_string({ "Hello", test});
	return 0;
}
void print_string(std::initializer_list<std::string> ls)
{
	for (auto &s : ls)
	{
		std::cout << s;
	}
	std::cout << std::endl;
}
```
### 14. å°æ–¼ä¸€å€‹voidé¡å‹çš„å‡½å¼ï¼Œæˆ‘å€‘å¯ä»¥ä½¿ç”¨returnä¾†ç•¶æˆbreakä½¿ç”¨ï¼Œç›´æ¥çµ‚æ­¢è©²å‡½å¼ã€‚
```c++
void swap(int &v1, int &v2)
{
	if(v1 == v2)
	{
		return;
	}

	int tmp = v2;
	v2 = v1;
	v1 = tmp;
}
```
### 15. åªè¦ä¸æ˜¯voidå‡½å¼å°±ä¸€å®šéƒ½è¦æœ‰å›å‚³å€¼ã€‚é€™å¥è©±æ˜¯çµ•å°çš„ï¼Œä½†æœ‰ä¸€å€‹ä¾‹å¤–ï¼Œå¦‚æœæˆ‘å€‘åœ¨main()å‡½å¼å…§æ²’æœ‰æ‰“å‡ºå›å‚³å€¼ï¼Œå®ƒæœƒè‡ªå·±é»˜èªç‚ºå›å‚³0ã€‚
### 16. æˆ‘å€‘ä¹Ÿå¯ä»¥"å‘¼å«"å‡½å¼æœ¬èº«(Recursion):
```c++
int factorial(int val) 
{
	if (val > 1)
	{
		return factorial(val-1) * val;
	}
	return 1;
}
```
### è¨»è¨˜:mainä¸èƒ½å›å‚³mainã€‚
### 17. æˆ‘å€‘ä¸èƒ½å›å‚³é™£åˆ—ã€‚
### 18. æˆ‘å€‘å¯ä»¥å›å‚³ä¸€å€‹å°é™£åˆ—çš„æŒ‡æ¨™ã€‚
```c++
typedef int arr[10];
arr *func(int i); //å‹åˆ¥æ˜¯ä¸€å€‹å°é™£åˆ—çš„æŒ‡æ¨™ æŒ‡å‘ä¸€å€‹ç”±10intçµ„æˆçš„é™£åˆ—
```
### 19. å°¾ç«¯å›å‚³é¡å‹:
```c++
auto func(int i) -> int(*)[10]; //å‹åˆ¥æ˜¯ä¸€å€‹å°é™£åˆ—çš„æŒ‡æ¨™ æŒ‡å‘ä¸€å€‹ç”±10intçµ„æˆçš„é™£åˆ—
```
### 20. é‡è¼‰å‡½å¼:å…·æœ‰ç›¸åŒåç¨±ï¼Œä½†åƒæ•¸åˆ—ä¸åŒçš„å‡½å¼ã€‚
### è¦æ³¨æ„ï¼Œmainä¸èƒ½é‡è¼‰ã€‚
### 21. è¦ä½¿ç”¨é‡è¼‰å‡½å¼ä¸€å®šè¦è¨˜å¾—ï¼Œåƒæ•¸çš„æ•¸é‡åˆæˆ–è€…æ˜¯å…¶ä¸­çš„å‹åˆ¥ä¸€å®šè¦ä¸ä¸€æ¨£ã€‚
### 22. æˆ‘å€‘å¯ä»¥ç‚ºå‡½å¼è¨­å®šè¨‚é è¨­åƒæ•¸ã€‚
### ä½†è¦æ³¨æ„çš„æ˜¯ï¼Œä¸€æ—¦ä½ ä½¿ç”¨äº†é è¨­åƒæ•¸ï¼Œé‚£å¾Œé¢çš„æ‰€æœ‰åƒæ•¸ä¹Ÿå¿…ç„¶éƒ½è¦æœ‰é è¨­å€¼ã€‚
### 23. å€åŸŸè®Šæ•¸ä¸èƒ½è¢«è¨­ç‚ºé è¨­åƒæ•¸:
```c++
typedef std::string::size_type sz;
sz wd = 80;
char def = '';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen(); //ht(), 80, ''

void f2()
{
	def = '*';
	sz wd = 100;
	window = screen(); //ht(), 80, *
}
```
### 24. å¯ä»¥ä½¿ç”¨inlineæ¸›å°‘å‡½å¼åŸ·è¡Œæ™‚æœŸçš„è² æ“”ã€‚
### 25. constexprå‡½å¼:å¿…é ˆå›å‚³å­—é¢å€¼å‹åˆ¥(æ•¸å­—ã€å­—ä¸²ã€å¸ƒæ—å€¼ã€ç¬¦è™Ÿ)ï¼Œåˆæˆ–è€…æ˜¯å¸¸æ•¸é‹ç®—å¼ã€‚
### 26. å‰ç½®è™•ç†å™¨å·¨é›†assertï¼Œé€šå¸¸ç”¨ä¾†æª¢æŸ¥ä¸å¯èƒ½ç™¼ç”Ÿçš„äº‹æƒ…ã€‚
### å¦‚æœè©²é‹ç®—å¼ç‚ºfalseï¼Œé‚£éº¼assertæœƒå¯«å‡ºä¸€æ®µè¨Šæ¯ï¼Œä¸¦ä¸”ç”šéº¼éƒ½ä¸åš;å¦‚æœç‚ºtrueï¼Œå‰‡æœƒç”šéº¼éƒ½ä¸ç®¡ã€‚
### 27. è¦è¨˜ä½ï¼Œassertæ˜¯ç”±å‰å™¨è™•ç†å™¨ç®¡ç†çš„ï¼Œæ‰€ä»¥æˆ‘å€‘å‘¼å«å®ƒçš„æ™‚å€™ï¼Œä¸ç”¨std::ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚
### ä½†ä½¿ç”¨å‰è¦è¨˜å¾—#include <cassert>
### 28. ç•¶æˆ‘å€‘å®šç¾©äº†NDEBUGä»£è¡¨è‘—ç¨‹å¼å·²ç¶“ä¸æ˜¯é–‹ç™¼ç‹€æ…‹äº†ï¼Œæ‰€ä»¥ä½¿ç”¨assertæ˜¯ç„¡ç”¨çš„ã€‚
```c++
#define NDEBUG
#include<cassert>
int main()
{
	int x = 0;
	assert(x); //æ˜¯ç„¡ç”¨çš„
	return 0
}
```
### 29. æˆ‘å€‘ä¹Ÿå¯ä»¥ä½¿ç”¨NDEBUGä¾†å®šç¾©è‡ªå·±çš„é™¤éŒ¯(ç¨‹å¼ç¢¼)æ–¹æ³•:
```c++
#ifndef NDEBUG
/*
ä¸­é–“æ”¾æˆ‘å€‘æƒ³è¦å°å‡ºçš„è¨Šæ¯
*/
#endif
```
### 30. å‰ç½®è™•ç†å™¨é‚„å®šç¾©äº†å››å€‹å¯ä»¥è®“æˆ‘å€‘é™¤éŒ¯æ™‚ä½¿ç”¨çš„åç¨±:
>> __FILE__ //æª”æ¡ˆå
>> __LINE__ //ç¬¬å¹¾è¡Œ
>> __TIME__ //æ™‚é–“
>> __DATE__ //æ—¥æœŸ
>> ä»¥åŠC++æä¾›çš„ __func__
### 31. ç•¶æˆ‘å€‘ä½¿ç”¨ä¸€å€‹å‡½å¼åç¨±ç•¶ä½œè®Šæ•¸çš„å€¼æ™‚ï¼Œé‚£å€‹å‡½å¼æœƒè¢«è‡ªå‹•è½‰æ›æˆä¸€å€‹æŒ‡æ¨™ã€‚
```c++
#include <iostream>
#include <vector>
#include <string>
bool length_compare(const std::string&, const std::string&);
int main()
{
	bool (*pf)(const std::string&, const std::string&); //a pointer point to a function that return bool
	pf = &length_compare; //like pointer well get the address of the function
	bool b1 = pf("hello", "hello"); //same
	bool b2 = (*pf)("hello", "hello"); //same we get the value that in the address where pf points
	if (b2)
	{
		std::cout << "1" << std::endl;
	}
	return 0;
}
bool length_compare(const std::string &s1, const std::string &s2)
{
	return s1.size() == s2.size() ? true : false;
}
```
### 32. æˆ‘å€‘å¯ä»¥å¦¥å–„çš„åˆ©ç”¨typedefè·Ÿdecltypeä¾†å®šç¾©å‡½å¼æŒ‡æ¨™çš„å‹åˆ¥ã€‚
```c++
typedef boo1 func1(const std::string, const std::string); //è¿”å›å‡½å¼
typedef decltype(length_compare) func2; //åŒä¸Š
typedef boo1 (*func3)(const std::string, const std::string); //è¿”å›æŒ‡æ¨™
typedef decltype(length_compare) *func3p; //decltypeè¿”å›çš„æ˜¯å‡½å¼å‹åˆ¥ï¼Œæ‰€ä»¥éœ€è¦é€šé*ä¾†å°‡å…¶è½‰æ›ç‚ºæŒ‡æ¨™
```
### 33. å‡½å¼ä¸å¯ä»¥è¿”å›å‡½å¼ï¼Œé€™ä»£è¡¨è‘—é‚„æ˜¯ä¸å¯ä»¥ç•¶æˆä¸€å€‹å‹åˆ¥ä¾†å®šç¾©å‡½å¼ã€‚
```c++
using F = int(int*, int); å‡½å¼
using PF = int(*)(int*, int); PFæ˜¯ä¸€å€‹æŒ‡æ¨™ï¼ŒæŒ‡å‘Fé¡å‹çš„å‡½å¼
PF f1(int); f1ç¾åœ¨æ˜¯ä¸€å€‹è¿”å›æŒ‡æ¨™çš„æŒ‡é‡ï¼ŒæŒ‡å‘F
F f1(int); éŒ¯ï¼Œf1æ²’è¾¦æ³•è¿”å›ä¸€å€‹å‡½å¼å‹åˆ¥
F *f1(int); f1æ˜¯ä¸€å€‹è¿”å›æŒ‡æ¨™çš„å‡½å¼ï¼ŒæŒ‡å‘F
int (*f1(int))(int*, int);
auto f1(int) -> int(*)(int*, int);
```
## 16 é¡åˆ¥(Classes):
### 1. å®šç¾©æˆå“¡å‡½å¼:
### åœ¨å…§éƒ¨å®šç¾©:isbn()
```c++
struct Sales_Data
{
	std::string book_Numbers = "";
	unsigned units_sold = 0;
	double revenue = 0.0;
	std::string isbn() const //å‘Šè¨´é›»è…¦isbnå…¶å¯¦æ˜¯è¦ä½¿ç”¨ä¸€å€‹å«åšthisçš„æŒ‡é‡ï¼ŒæŒ‡å‘å›å‚³å€¼ï¼Œè€Œä¸”å®ƒæ˜¯å¸¸é‡çš„ï¼Œä¸èƒ½æ”¹è®Š //Sales_Data::isbn(&total) å¦‚æœæˆ‘å€‘è¦æ‹¿totalçš„booknumsçš„è©±
	{
		return book_Numbers;
	}//ä»£è¡¨æˆ‘å€‘åªèƒ½è®€å–isbnä¸­çš„å€¼ï¼Œä½†ä¸èƒ½æ”¹å¯«
	Sales_Data& combine(const Sales_Data&); //combineé€™å€‹å‡½å¼å›å‚³çš„æ˜¯ä¸€å€‹Sales_Dataå‹åˆ¥çš„åƒè€ƒ
	double avg_price() const;
};
```
### åœ¨å¤–éƒ¨å®šç¾©:avg_price()
```c++
double Sales_Data::avg_price() const
{
	
	if (units_sold)
	{
		return revenue / units_sold;
	}
	else
	{
		return 0;
	}

}
```
### ä½¿ç”¨*thiså›å‚³ç‰©ä»¶(è³‡æ–™çµæ§‹)æœ¬èº«:
```c++
/*
* combine()å‡½å¼è§£é‡‹:å‡è¨­æœ‰å…©å€‹Sales_Data:data1è·Ÿdata2
* å¦‚æœæˆ‘ç¾åœ¨æ˜¯å‘¼å«data1.combine(data2)ä»£è¡¨è‘—æˆ‘å€‘è¦åšdata1 = data1 + data2;
*/
Sales_Data& Sales_Data::combine(const Sales_Data& rhs) 
{
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this; //å›å‚³dataæœ¬èº«ä¸”æ˜¯åƒè€ƒå‹åˆ¥çš„ï¼Œä»£è¡¨æœƒæ”¹è®Šdataæœ¬èº«åŸæœ‰çš„å€¼ ç”¨ä¾†å›å‚³ç‰©ä»¶æ•´é«”
}
```
### 2. å®šç¾©éæˆå“¡å‡½å¼:
### é€šå¸¸å®šç¾©åœ¨åŒä¸€å€‹æ¨™é ­é»¨(.h)ä¸­ã€‚
```c++
/*
* è‡ªå·±å®šç¾©iostream
*/
std::istream& read(std::istream& in, Sales_Data& item)
{
	double price = 0; //æ¯æœ¬æ›¸çš„åƒ¹éŒ¢

	in >> item.book_Numbers >> item.units_sold >> price; //å¯ä»¥è¼¸å…¥isbnã€è³£äº†å¹¾æœ¬ã€è·Ÿä¸€æœ¬å¤šå°‘å‰
	item.revenue = price * item.units_sold; //è¨ˆç®—ç¸½ç²åˆ©
	return in; //å›å‚³std::cin
}
std::ostream& print(std::ostream& out, Sales_Data& item)
{
	out << item.isbn() << " " << item.units_sold << " " << item.avg_price()
		<< " " << item.revenue;
	return out;
}
```
### è¨»è¨˜:iostreamå‹åˆ¥ç„¡æ³•è¢«æ‹·è²ï¼Œåªèƒ½ä½¿ç”¨åƒè€ƒ(å› ç‚ºæˆ‘å€‘åœ¨å®šç¾©ä¸€å€‹è®Šæ•¸çš„æ™‚å€™ï¼Œå…¶å¯¦å°±ä¾é æ‹·è²çš„æ–¹å¼å®šç¾©)ã€‚
```c++
/*
* å®šç¾©ç›¸åŠ 
*/
Sales_Data add(const Sales_Data& data1, const Sales_Data& data2)
{
	Sales_Data sum = data1;
	sum.combine(data2); //data1+data2

	return sum; //return data1+data2
}
```
### å®Œæ•´ç¨‹å¼ç¢¼:
```c++
#include<iostream>
#include<string>
//å®šç¾©æˆå“¡å‡½å¼
/*
* 1.èƒ½å¤ å›å‚³isbnï¼Œå‘½åç‚ºisbn()
* 2.èƒ½å°‡åŒæ¨£Sales_dataé€™å€‹å‹åˆ¥çš„ç‰©ä»¶åŠ åˆ°å¦ä¸€å€‹ä¸Šï¼Œå‘½ç‚ºåcombie()
* 3.ç›¸åŠ å…©å€‹ç›¸åŒçš„Sales_dataï¼Œå‘½åç‚ºadd()
* 4.å¾istream(cin)ä¸­è®€å–è³‡æ–™åˆ°Sales_dataå…§ï¼Œå‘½åç‚ºread()
* 5.å¾ostream(cout)ä¸Šå°å‡ºSales_dataå…§çš„ç‰©ä»¶ï¼Œå‘½åç‚ºprint()
*/
/*
* 1.å¸¸é‡æŒ‡é‡:æŒ‡å‘å¸¸é‡çš„æŒ‡é‡
* const int *cptr; //å¯ä»¥ä¸ç”¨åˆå§‹åŒ–
* 2.æŒ‡é‡å¸¸é‡:æŒ‡é‡æ˜¯å¸¸é‡çš„ï¼Œä¸€é–‹å§‹æ˜¯å¤šå°‘å°±æ˜¯å¤šå°‘
* int *const ptrc = &a; //å¿…é ˆåˆå§‹åŒ–
*/
struct Sales_Data
{
	std::string book_Numbers = "";
	unsigned units_sold = 0;
	double revenue = 0.0;
	std::string isbn() const //å‘Šè¨´é›»è…¦isbnå…¶å¯¦æ˜¯è¦ä½¿ç”¨ä¸€å€‹å«åšthisçš„æŒ‡é‡ï¼ŒæŒ‡å‘å›å‚³å€¼ï¼Œè€Œä¸”å®ƒæ˜¯å¸¸é‡çš„ï¼Œä¸èƒ½æ”¹è®Š //Sales_Data::isbn(&total) å¦‚æœæˆ‘å€‘è¦æ‹¿totalçš„booknumsçš„è©±
	{
		return book_Numbers;
	}//ä»£è¡¨æˆ‘å€‘åªèƒ½è®€å–isbnä¸­çš„å€¼ï¼Œä½†ä¸èƒ½æ”¹å¯«
	Sales_Data& combine(const Sales_Data&); //combineé€™å€‹å‡½å¼å›å‚³çš„æ˜¯ä¸€å€‹Sales_Dataå‹åˆ¥çš„åƒè€ƒ
	double avg_price() const;
};
double Sales_Data::avg_price() const
{	
	if (units_sold)
	{
		return revenue / units_sold;
	}
	else
	{
		return 0;
	}
}
/*
* combine()å‡½å¼è§£é‡‹:å‡è¨­æœ‰å…©å€‹Sales_Data:data1è·Ÿdata2
* å¦‚æœæˆ‘ç¾åœ¨æ˜¯å‘¼å«data1.combine(data2)ä»£è¡¨è‘—æˆ‘å€‘è¦åšdata1 = data1 + data2;
*/
Sales_Data& Sales_Data::combine(const Sales_Data& rhs) 
{
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this; //å›å‚³dataæœ¬èº«ä¸”æ˜¯åƒè€ƒå‹åˆ¥çš„ï¼Œä»£è¡¨æœƒæ”¹è®Šdataæœ¬èº«åŸæœ‰çš„å€¼ ç”¨ä¾†å›å‚³ç‰©ä»¶æ•´é«”
}
/*
* è‡ªå·±å®šç¾©iostream
*/
std::istream& read(std::istream& in, Sales_Data& item)
{
	double price = 0; //æ¯æœ¬æ›¸çš„åƒ¹éŒ¢
	in >> item.book_Numbers >> item.units_sold >> price; //å¯ä»¥è¼¸å…¥isbnã€è³£äº†å¹¾æœ¬ã€è·Ÿä¸€æœ¬å¤šå°‘å‰
	item.revenue = price * item.units_sold; //è¨ˆç®—ç¸½ç²åˆ©
	return in; //å›å‚³std::cin
}
std::ostream& print(std::ostream& out, Sales_Data& item)
{
	out << item.isbn() << " " << item.units_sold << " " << item.avg_price()
		<< " " << item.revenue;
	return out;
}
/*
* å®šç¾©ç›¸åŠ 
*/
Sales_Data add(const Sales_Data& data1, const Sales_Data& data2)
{
	Sales_Data sum = data1;
	sum.combine(data2); //data1+data2
	return sum; //return data1+data2
}
int main()
{	
	Sales_Data data1, data2, total;
	read(std::cin, data1); //read the data:isbn, unit_sold, price for each books
	read(std::cin, data2);
	if (data1.isbn() != data2.isbn())
	{
		std::cerr << "Invalid Input." << std::endl;
		return -1;
	}
	else
	{
		total = add(data1, data2);
		print(std::cout, total); //print the data:isbn, unit_sold, price for each books, revenue
		return 0;
	}
}
```
### 3. å»ºæ§‹å™¨(æ§‹é€ å‡½å¼):ç”¨ä¾†åˆå§‹åŒ–é¡åˆ¥(Classes)çš„ç‰¹æ®Šæˆå“¡å‡½å¼ã€‚
### 4. ç•¶æˆ‘å€‘æ²’æœ‰å®šç¾©"ä»»ä½•"å»ºæ§‹å™¨(æ§‹é€ å‡½å¼)ï¼Œé‚£éº¼ç³»çµ±å°±æœƒç‚ºæˆ‘å€‘å®šç¾©é è¨­çš„å»ºæ§‹å™¨(æ§‹é€ å‡½å¼):synthesized default constructor
### 5. åªæœ‰ç›¸ç•¶ç°¡å–®çš„calssesæ‰èƒ½ä»°è³´é è¨­çš„å»ºæ§‹å™¨ï¼Œé€šå¸¸ä¾†èªªæˆ‘å€‘éƒ½éœ€è¦è‡ªå·±å®šç¾©ã€‚
### åŸå› :å› ç‚ºè®Šæ•¸åœ¨æœªå®šç¾©æ™‚ï¼Œæœƒä½¿ç”¨é è¨­åˆå§‹åŒ–çš„ï¼Œé€™çµ•å¤§å¤šæ•¸éƒ½ä¸æ˜¯æˆ‘å€‘æƒ³è¦çš„ã€‚å†ä¾†ï¼Œæœ‰äº›æ™‚å€™ç·¨è­¯å™¨æœƒç„¡æ³•åˆæˆï¼Œé€™å°è‡´å®ƒç„¡æ³•å¹«æˆ‘å€‘åˆå§‹åŒ–é‚£äº›æ²’æœ‰è¢«å®šç¾©çš„æˆå“¡ã€‚
### 6. å»ºæ§‹å™¨(æ§‹é€ å‡½å¼)ä¸èƒ½å®£å‘Šç‚ºconstå‹åˆ¥ã€‚
### å»ºæ§‹å™¨ç¯„ä¾‹:
```c++
struct Sales_Data
{
	Sales_Data() = default; //å› ç‚ºæˆ‘å€‘å·²ç¶“æœ‰å°è®Šæ•¸é€²è¡Œåˆå§‹åŒ–äº†
	Sales_Data(const std::string s, unsigned n, double p) :
		book_Numbers(s), units_sold(n), revenue(n* p){}
	Sales_Data(std::istream&);
	std::string book_Numbers; = "";
	unsigned units_sold = 0;
	double revenue = 0.0;
	std::string isbn() const;
	Sales_Data& combine(const Sales_Data&); //combineé€™å€‹å‡½å¼å›å‚³çš„æ˜¯ä¸€å€‹Sales_Dataå‹åˆ¥çš„åƒè€ƒ
	double avg_price() const;
};
Sales_Data::Sales_Data(std::istream& in)
{
	read(in, *this);
}
```
## 17 å­˜å–èˆ‡å°è£:
### 1. public:æ•´å€‹ç¨‹å¼å…§éƒ½å¯ä»¥è¢«å­˜å–ã€‚
### 2. private:åªèƒ½åœ¨classè£¡é¢å¯¦ç¾ã€‚
### 3. ä½¿ç”¨friendä¾†å­˜å–privateå…§çš„è®Šæ•¸ã€‚
```c++
#include<iostream>
#include<string>
/*
* è¨­è¨ˆä¸€å€‹ç¨‹å¼ï¼ŒåŠŸèƒ½åŒ…å«:
* 1.è¼¸å…¥isbn
* 2.è¼¸å…¥è²©è³£æ•¸é‡
* 3.è¼¸å…¥ä¸€æœ¬æ›¸çš„åƒ¹éŒ¢
* 4.æœ€å¾Œå°å‡º: isbn/ç¸½éŠ·é‡/ç¸½ç²åˆ©/å¹³å‡å‡ºå”®åƒ¹éŒ¢
*/
class Sales_Data
{
	friend Sales_Data add(const Sales_Data&, const Sales_Data&);
	friend std::istream& read(std::istream&, Sales_Data&);
	friend std::ostream& print(std::ostream&, const Sales_Data&);
	public:
		//å»ºæ§‹å™¨
		Sales_Data() = default;
		Sales_Data(std::istream&);
		Sales_Data(const std::string s, unsigned n, double r) :
			book_Nos(s), unit_sold(n), revenue(n * r) {}
		std::string isbn () const; //print isbn
		Sales_Data& combine(const Sales_Data&); //combine 2 objects to make the new object
		//print the result: isbn, total_sold, average_price, total_revenue
	private:
		std::string book_Nos = "";
		unsigned unit_sold = 0;
		double revenue = 0.0;
		double avg_price() const
		{
			return unit_sold ? revenue / unit_sold : 0;
		}		
};
Sales_Data add(const Sales_Data&, const Sales_Data&);
std::istream& read(std::istream&, const Sales_Data&);
std::ostream& print(std::ostream&, const Sales_Data&);
std::string Sales_Data::isbn() const
{
	return book_Nos;
}
Sales_Data& Sales_Data::combine(const Sales_Data& new_data)
{
	unit_sold += new_data.unit_sold;
	revenue += new_data.revenue;
	return *this;
}
Sales_Data add(const Sales_Data& data_1, const Sales_Data& data_2)
{
	Sales_Data sum = data_1;
	sum.combine(data_2);
	return sum;
}
//define iostream
std::istream& read(std::istream& in/*cin*/, Sales_Data& data)
{
	double price = 0.0;
	in >> data.book_Nos >> data.unit_sold >> price;
	data.revenue = data.unit_sold * price;

	return in;
}
std::ostream& print(std::ostream& out/*out*/, const Sales_Data& data)
{
	out << data.book_Nos << " "<< data.unit_sold << " " << data.avg_price()
		<< " " << data.revenue << std::endl;
	return out;
}
Sales_Data::Sales_Data(std::istream& in)
{
	read(in, *this);
}
int main()
{
	Sales_Data data_1, data_2;
	read(std::cin, data_1);
	read(std::cin, data_2);
	if (data_1.isbn() == data_2.isbn())
	{
		Sales_Data new_data = add(data_1, data_2);
		print(std::cout, new_data);
	}
	else
	{
		std::cerr << "Invalid Input." << std::endl;
	}
	return 0;
}
```
### 4. ä½¿ç”¨mutableä¾†æ”¹è®Šclasseså…§éƒ¨çš„æˆå“¡ï¼Œå“ªæ€•å®ƒæ˜¯constã€‚
```c++
class Screen
{
	public:
		void some_member() const;
	private:
		mutable size_t access_ctr;
};
void Screen:some_member() const
{
	++access_ctr;
}
```
### 5. classesçš„åˆå§‹åŒ–:
```c++
class Screen
{
public:
	typedef std::string::size_type pos;
	Screen() = default;
	Screen(pos ht, pos wd, char c):
		height(ht), width(wd), contents(ht * wd, c) {}
	char get() const
	{
		return contents[curson];
	}
	inline char get(pos ht, pos wd) const;
	Screen& move(pos r, pos c);
private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;

};
class Window_mgr
{
private:
	std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```
### 6. å›å‚³*this
```c++
Screen& move(pos r, pos c);
Screen& set(char c);
```
### å¦‚æœæˆ‘å€‘å›å‚³çš„æ˜¯ä¸€å€‹reference(Screen)ï¼Œä»£è¡¨è‘—æˆ‘å€‘å¯ä»¥ç›´æ¥æ”¹è®Šç‰©ä»¶æœ¬èº«ã€‚ä½†å¦‚æœåªæ˜¯å›å‚³(Screen)ï¼Œé‚£å°±åƒæ˜¯æˆ‘å€‘åœ¨å®šç¾©è®Šæ•¸ä¸€æ¨£ï¼Œåªæ˜¯åœ¨åšæ‹·è²è€Œå·²ã€‚
### å›å‚³referenceçš„æµç¨‹å¤§è‡´å¦‚ä¸‹:
![Reference](https://github.com/littleyu0820/Interview_Leetode/blob/main/PitcturesForLearning/%E5%9B%9E%E5%82%B3%E5%8F%83%E8%80%83.png)
### å›å‚³éreferenceçš„æµç¨‹å¤§è‡´å¦‚ä¸‹:
![Non-Reference](https://github.com/littleyu0820/Interview_Leetode/blob/main/PitcturesForLearning/%E5%9B%9E%E5%82%B3%E6%8B%B7%E8%B2%9D%E5%80%BC.png)
### 7. claaä¹Ÿå¯ä»¥ç•¶classçš„frinedã€‚ç°¡å–®é»ä¾†è¬›ï¼Œæˆ‘å€‘å¯ä»¥åœ¨ä¸€å€‹classå…§éƒ¨friendå¦å¤–ä¸€å€‹classã€‚
```c++
class Screen
{
	friend class Window_mgr;
};
```
### 8. æ¯å€‹classéƒ½åˆ†åˆ¥æ§åˆ¶è‘—è‡ªå·±çš„æˆå“¡ã€å‡½å¼ï¼Œä»¥åŠæœ‹å‹ã€‚é€™ä»£è¡¨èªªç•¶class Bè¦ä½¿ç”¨class Aè£¡é¢çš„æ±è¥¿çš„æ™‚å€™ï¼Œéœ€è¦åœ¨class Aè£¡é¢èªªæ¸…æ¥šï¼Œé‚£éº¼class Bæ‰èƒ½æ‹¿ã€‚
### 9. ç•¶æˆ‘å€‘åªæƒ³è¦è®“class Bä¸­çš„æŸå€‹å‡½å¼æœ‰è³‡æ ¼ä½¿ç”¨class Aè£¡é¢çš„æ±è¥¿æ™‚ï¼Œæˆ‘å€‘ä¹Ÿå¯ä½¿ç”¨ä»¥ä¸‹é€™å€‹æ–¹æ³•:
```c++
class A
{
	friend void B::test(); //è¡¨ç¤ºclass Bä¸­æœ‰ä¸€å€‹å›å‚³å‹åˆ¥æ˜¯voidçš„å‡½å¼å¯ä»¥ä½¿ç”¨class Aä¸­çš„æ±è¥¿
};
```
### 10. ç•¶æˆ‘å€‘åœ¨ä¸€å€‹classå…§éƒ¨friendä¸€å€‹å‡½å¼æˆ–classæ™‚ï¼Œå…¶å¯¦ç·¨è­¯å™¨å°±å·²ç¶“éš±å«çš„å¹«æˆ‘å€‘å®£å‘Šé€™å€‹å‡½å¼æˆ–classäº†ã€‚
### ä½†é€™å…¶å¯¦åƒ…ä¾·é™æ–¼é‚£å€‹classä¸­ï¼Œé€™ä¹Ÿæ˜¯ç‚ºç”šéº¼æˆ‘å€‘é‚„éœ€è¦åœ¨classå¾Œé¢æˆ–å‰é¢ï¼Œå†é€²è¡Œå®£å‘Šä¸€æ¬¡çš„é—œä¿‚ã€‚
### 11. å®šç¾©ä¸€å®šæœƒåœ¨ç·¨è­¯å™¨è™•ç†å®Œæ‰€æœ‰å®£å‘Šå¾Œæ‰é–‹å§‹è™•ç†ã€‚
### 12. æˆ‘å€‘å¯ä»¥æŠŠå»ºæ§‹å™¨(constructor)æƒ³æˆä¸€å€‹è¤‡é›œå‹çš„intæˆ–stringï¼Œè®Šæ•¸åç¨±å¾Œçš„æ‹¬è™Ÿå…§éƒ¨æ‰€çµ¦å®šçš„å€¼ï¼Œå°±å¦‚åŒæˆ‘å€‘åœ¨å°int a = 10ï¼Œè³¦å€¼ä¸€æ¨£ã€‚
### æ–¹æ³•ä¸€ï¼Œç›´æ¥åœ¨classå…§åˆå§‹åŒ–:
```c++
class Sales_Data
{
	public:
		//å»ºæ§‹å™¨
		//å®šç¾©æ§‹é€ å‡½å¼ï¼Œåˆæˆ–è€…èªªå‘Šè¨´é›»è…¦ï¼ŒSales_Dataå…§éƒ¨å¾…æœƒéœ€è¦æ”¾å…¥ä¸‰å€‹å€¼
		Sales_Data(const std::string s, unsigned n, double r) :
			book_Nos(s), unit_sold(n), revenue(n * r) { }
		//æ§‹é€ å‡½æ•¸end
		Sales_Data():Sales_Data("", 0, 0) {} //åˆå§‹åŒ–
	private:
		std::string book_Nos;
		unsigned unit_sold;
		double revenue;
		double avg_price() const
		{
			return unit_sold ? revenue / unit_sold : 0;
		}		
};
```
### æ–¹æ³•äºŒï¼Œå¦‚åŒæˆ‘å€‘åœ¨å®šç¾©è®Šæ•¸ä¸€æ¨£ï¼Œåœ¨main()å‡½å¼è£¡å®šç¾©å®ƒ:
```c++
class Sales_Data
{
	public:
		//å»ºæ§‹å™¨
		//å®šç¾©æ§‹é€ å‡½å¼ï¼Œåˆæˆ–è€…èªªå‘Šè¨´é›»è…¦ï¼ŒSales_Dataå…§éƒ¨å¾…æœƒéœ€è¦æ”¾å…¥ä¸‰å€‹å€¼
		Sales_Data(const std::string s, unsigned n, double r) :
			book_Nos(s), unit_sold(n), revenue(n * r) { }
		//æ§‹é€ å‡½æ•¸end
	private:
		std::string book_Nos;
		unsigned unit_sold;
		double revenue;
		double avg_price() const
		{
			return unit_sold ? revenue / unit_sold : 0;
		}		
};
int main()
{
	Sales_Data data1("", 0, 0); //åˆ†åˆ¥å°isbnè³¦å€¼ç©º,unit_soldè³¦å€¼0,priceè³¦å€¼0
	return 0;
}
```
### 13. å½™ç¸½é¡åˆ¥/èšåˆ(Aggregate Class):
### ä½¿ç”¨æ¢ä»¶:A. æˆå“¡éƒ½æ˜¯public B. æ²’æœ‰å®šç¾©ä»»ä½•å»ºæ§‹å™¨ C. æ²’æœ‰åœ¨classesè£¡åˆå§‹åŒ– D. æ²’æœ‰base classeså’Œvirtualå‡½å¼ã€‚
### ç¯„ä¾‹:
```c++
struct Data
{
	int ival;
	string s;
}


int main()
{
	Data data1 = {10, "test"};
	return 0;
}
```
è¨»è¨˜:å¿…é ˆè¦æŒ‰ç…§è®Šæ•¸å®£å‘Šçš„é †åºä¾†å®šç¾©ã€‚
### 14. Satic:æ¯ä¸€å€‹staticæˆå“¡éƒ½æ˜¯ç”±æ•´å€‹classå…±ç”¨çš„ã€‚
### 15. Staticæ²’æœ‰referenceè·Ÿpointerï¼Œä¹Ÿä¸èƒ½å®£å‘Šç‚ºconstã€‚
### 16. Staticçš„å®šç¾©ä¸€å®šè¦åœ¨classeså¤–é¢ã€‚
### 17. ä½†æ˜¯å¦‚æœä½ åŠ ä¸Šconstexprå°±å¯ä»¥åœ¨classeså…§é€²è¡Œåˆå§‹åŒ–ã€‚ä½†é€™å€‹åˆå§‹åŒ–ï¼Œé‚„æ˜¯åªä¾·é™æ–¼è©²classesè£¡é¢ã€‚
### 18. å­˜å–staticçš„memberæ™‚ä¸€å®šè¦è¨˜å¾—ä½¿æ“ç¯„ç–‡é‹ç®—å­"::"ã€‚
```c++
class Account()
{
public:
private:
	static conxtexpr int period = 30; //periodçš„åˆå§‹åŒ–å€¼30å€¼åœ¨accountè£¡é¢æœ‰ç”¨
};
/*å¦‚æœæƒ³åœ¨å¤–é¢ç¹¼çºŒä½¿ç”¨å‰‡å¯ä»¥åœ¨classå¤–éƒ¨åœ¨å®šç¾©ä¸€æ¬¡*/
constexpr int Account::period;
```
## ç·´ç¿’é¡Œ15
### æ–¹æ³•:
```c++
#include <iostream>
#include <string>
/*
* è¨­è¨ˆä¸€å€‹éŠ€è¡Œå¸³æˆ¶ç®¡ç†ç¨‹å¼
* åŠŸèƒ½åŒ…å«:å¯ä»¥è¼¸å…¥ç”¨æˆ¶åã€å¸³è™Ÿéå»é‡‘é¡ã€åˆ©ç‡ã€ç¶“éäº†å¹¾å¤©ï¼Œä»¥åŠç•¶å‰ç¸½é‡‘é¡(éå»é‡‘é¡ * (1+åˆ©ç‡))
* åˆ©ç‡è®ŠåŒ–æ˜¯ç”±å¤©æ•¸æ±ºå®šçš„:180å¤©ä»¥ä¸Šçš„è©±å°±è®Šæˆ1.2å€(åˆ©ç‡*1.2)ï¼Œä»¥ä¸‹å°±ç¶­æŒä¸è®Š
* é¡¯ç¤ºå‡ºç”¨æˆ¶ç¶“éäº†å¹¾å¤©ä¹‹å¾Œï¼Œå¸³æˆ¶ç¸½é‡‘é¡è®Šæˆå¤šå°‘äº†
*/
class Bank_Manage
{
	//friend
	friend std::istream& read(std::istream&, Bank_Manage&);
	friend std::ostream& print(std::ostream&, Bank_Manage&)
public:
	//calculate the money after the interestrate
	void calculate()
	{
		amount += amount * interest_rate;
	}
	//constructor
	Bank_Manage(const std::string& name, double money):
		owner(name), amount(money){}
	//initialize
	Bank_Manage():Bank_Manage("", 0){}
private:
	std::string owner;
	double amount;
	//static member need to be initialized outside
	static double interest_rate;
	static double init_rate(double);
	static unsigned period;
};
//initialzie the static member variable
double Bank_Manage::interest_rate = 0.0;
unsigned Bank_Manage::period = 0;
//declare the friend
std::istream& read(std::istream&, Bank_Manage&);
std::ostream& print(std::ostream&, Bank_Manage&);
//initialzie the static member function
double Bank_Manage::init_rate(double r)
{
	if (r <= 180)
	{
		return 1.0;
	}
	else
	{
		return 1.2;
	}
}
//design the function what we need
std::istream& read(std::istream& in, Bank_Manage& user)
{	
	std::cout << "User Name:" << std::endl;
	in >> user.owner;
	std::cout << "User Amount:" << std::endl;
	in >> user.amount;
	std::cout << "The Rate is:" << std::endl;
	in >> user.interest_rate;
	//static variable (public)
	std::cout << "How long does the user save?" << std::endl;
	in >> user.period;
	user.interest_rate  = user.interest_rate * Bank_Manage::init_rate(user.period);
	return in;
}
//decide the print what we need
std::ostream& print(std::ostream& out, Bank_Manage& user)
{
	out << "The rate is: " << user.interest_rate << std::endl;
	user.calculate();
	out << "After " << user.period << " days. " << "User: " << user.owner << " has " << user.amount << " dollars now." << std::endl;
	return out;
}
int main()
{
	Bank_Manage owner1;
	read(std::cin, owner1);
	print(std::cout, owner1);
	return 0;
}
```

## 18 IOç¨‹å¼åº«:
### 1. åˆ†åˆ¥æœ‰ä¸‰ç¨®:iostreamã€fstreamï¼Œä»¥åŠsstreamã€‚
### iostream:ç”¨ä¾†è®€å¯«è³‡æ–™æµã€‚
### fstream:ç”¨ä¾†è®€å¯«å…·æª”åçš„å‹åˆ¥ã€‚
### iostream:ç”¨ä¾†è®€å¯«è¨˜æ†¶é«”å…§çš„stringã€‚
### 2. é€šå¸¸æˆ‘å€‘åœ¨ä½¿ç”¨ç¨‹å¼ç¢¼ä¹‹å‰ï¼Œæ‡‰è©²å…ˆæª¢æŸ¥å®ƒçš„è³‡æ–™æµæ˜¯å¦æœ‰å•é¡Œï¼Œå¦‚ä¸‹:
```c++
while(std::cin >> word) //æª¢æŸ¥cinæ˜¯å¦æœ‰æ­£ç¢ºå›å‚³
{
}
```
### ä½†ä¸Šé¢é€™ç¨®æ–¹æ³•åªæœƒå‘Šè¨´æˆ‘å€‘é€™å€‹è³‡æ–™æµæ˜¯å¦æœ‰æ•ˆï¼Œä¸¦ä¸æœƒå‘Šè¨´æˆ‘å€‘ç™¼ç”Ÿäº†ç”šéº¼ã€‚
### 3. è¦æƒ³çŸ¥é“ç™¼ç”Ÿäº†ç”šéº¼ï¼ŒIOè³‡æ–™åº«é¡å¤–å®šç¾©äº†ä¸€å€‹æ•´æ•¸å‹åˆ¥"iostate"ã€‚
### è¦è¨˜å¾—ï¼Œiostateå­˜æ”¾æ–¼å‡½å¼åº«strm::iostateã€‚
### badbit:è¡¨ç¤ºç³»çµ±å±¤ç´šçš„éŒ¯èª¤ï¼Œå¦‚:ç„¡æ³•å¾©åŸçš„è®€å–æˆ–å¯«å…¥éŒ¯èª¤ã€‚é€šå¸¸é€™ç¨®éŒ¯èª¤ç™¼ç”Ÿå°±ä»£è¡¨è‘—é€™å€‹è³‡æ–™æµç„¡æ³•ä½¿ç”¨äº†ã€‚
### failbit:è¡¨ç¤ºå‡ºç¾å¯å¾©åŸçš„éŒ¯èª¤ï¼Œå¦‚:é æœŸå¾—åˆ°æ•¸å­—ï¼Œå»å¾—åˆ°å­—å…ƒã€‚
### eofbit:è¡¨ç¤ºåˆ°é”æª”æ¡ˆçµå°¾äº†ã€‚
### goodbit:è¡¨ç¤ºæ²’æœ‰éŒ¯èª¤ï¼Œä¿è­‰æœƒæœ‰å€¼0ã€‚
### 4. æˆ‘å€‘å¯ä»¥é€šérestateé€™å€‹å‡½å¼ä¾†å›å‚³ç›®å‰çš„è³‡æ–™æµç‹€æ…‹ã€‚
```c++
auto state = cin.rdstate(); //å›å‚³ç‹€æ…‹
cin.clear(); //ä½¿cinæœ‰æ•ˆ
```
### 5. æ¸…é™¤ç·©è¡å€çš„æ–¹æ³•:
```c++
std::cout << s << std::endl; //æ›è¡Œ(newline)ç„¶å¾Œæ¸…ç©º
std::cout << s << std::flush; //æ¸…ç©º
std::cout << s << std::ends; //è¼¸å…¥ä¸€å€‹nullç„¶å¾Œæ¸…ç©º
```
### 6. ä¹Ÿå¯ä»¥é€šéunitbufä¾†è¨­å®šæ¯ä¸€æ¬¡è¼¸å‡ºéƒ½è¦æ¸…ç©ºç·©è¡å€:
```c++
std::cout << std::unitbuf; //è¨­å®šæ¯æ¬¡éƒ½æ¸…ç©º
std::cout << std::nounitbuf; //æ¢å¾©æ­£å¸¸
```
### 7. æˆ‘å€‘æœ‰å¯ä»¥å°‡è¼¸å…¥èˆ‡è¼¸å‡ºç¶åœ¨ä¸€å™¨ï¼Œé€™æ¨£æ¯æ¬¡è®€å–æ™‚å°±æœƒéƒ½æœƒå…ˆæ¸…ç©ºç·©è¡å€ã€‚
### äº’å‹•å¼ç³»çµ±æœ€å¸¸ä½¿ç”¨é€™å€‹æ–¹æ³•ï¼Œé€™æ¨£å­æ¯æ¬¡éƒ½æœƒåœ¨è©¦è‘—è®€å–è¼¸å…¥å‰å°±å…ˆè¢«å¯«å‡ºäº†ã€‚
```c++
int main()
{
	std::string s = "hello";
	std::cin.tie(&std::cout);  //ç¶å®šcin/cout //é€™æ˜¯å‡½å¼åº«å…§å»ºçš„
	std::cin >> s;
	std::ostream* old_tie = std::cin.tie(nullptr); //è§£é™¤ç¶å®š
	return 0;
}
```
### 8. å¦‚æœæˆ‘å€‘çš„cinè·Ÿcoutæ²’æœ‰å…§å»ºç¶å®šï¼Œç·©è¡å€æœªè¢«é‡‹æ”¾ï¼Œé‚£ä»£è¡¨è‘—ç¨‹å¼æœƒä¸€å€¼è™•æ–¼ç­‰å¾…ç‹€æ…‹ï¼Œä¸æœƒè‡ªå‹•å‘ä¸‹åŸ·è¡Œ:
```c++
int val = 0;
std::cout << "Enter a number...";
std::cin >> val;
```
### ç¨‹å¼æœƒå¡åœ¨couté‚£ï¼Œå› ç‚ºç·©è¡å€æ²’æœ‰è¢«é‡‹æ”¾å‡ºä¾†ã€‚ç•¶ç„¶ï¼Œæœ‰äº›é›»è…¦ä¸æœƒé€™æ¨£å–”!
### 9. fstreamä¸­çš„ä¸‰ç¨®å‹åˆ¥:
### ifstream:è®€å–æª”æ¡ˆ
### ofstream:å¯«å…¥æª”æ¡ˆ
### fstream:è®€å¯«æª”æ¡ˆ
```c++
ifstream in(file)
ofstream out;
out.open(file + ".copy");
```
### 10. ä¸€æ—¦æª”æ¡ˆè¢«é–‹å•Ÿï¼Œå®ƒå°±æœƒæŒçºŒåˆ°å€close()ç‚ºæ­¢ã€‚
### 11. istringstreamçš„æ‡‰ç”¨ï¼Œç”¨ä¾†è™•ç†ä¸€æ•´è¡Œçš„è¼¸å…¥ã€‚
## ç·´ç¿’é¡Œ16
```c++
#include <iostream>
#include <vector>
#include <string> 
#include <fstream>
#include <sstream>
/*
* è¨­è¨ˆä¸€å€‹é›»è©±æœ¬ç¨‹å¼ï¼Œç”¨ä¾†è¨˜éŒ„åå­—èˆ‡é›»è©±è™Ÿç¢¼
* å‡å®šè¼¸å…¥é †åºç‚ºåå­—ã€æ‰‹æ©Ÿã€å®¶è£¡é›»è©±
* è¼¸å‡ºçµæœç‚ºåå­—èˆ‡æ‰‹æ©Ÿ
*/
int main()
{
	struct Person_Info
	{
		std::string name; //åå­—
		std::vector<std::string> phones; //å­˜æ”¾å¤šç¨®é›»è©±
	};

	std::string line, word;
	std::vector<Person_Info> people;
	while (getline(std::cin, line)) //è¼¸å…¥
	{
		Person_Info info; //ç•¶å‰è³‡æ–™
		std::istringstream record(line); //ç´€éŒ„è¼¸å…¥å€¼
		record >> info.name; //å‡è¨­ç¬¬ä¸€ç­†è³‡æ–™å¿…ç„¶ç‚ºåå­—
		while (record >> word) //å¾Œé¢éƒ½æ˜¯é›»è©±
		{
			info.phones.push_back(word); //å°‡é›»è©±ä¸€ç­†ä¸€ç­†å­˜é€²vectorä¸­
		}
		people.push_back(info); //å…¨éƒ¨å­˜åˆ°peopleä¸­(é›»è©±æœ¬)
	}
	for (auto& p : people)
	{
		std::cout << p.name  << p.phones[0] << std::endl; //è¼¸å‡ºåå­—/æ‰‹æ©Ÿè™Ÿç¢¼
	}
	return 0;
}
```
### 12. ostringstreamçš„æ‡‰ç”¨ï¼Œè™•ç†å®Œå¾Œåœ¨è¼¸å‡ºã€‚
### ä»¥ä¸‹ç‚ºç¯„ä¾‹ç¨‹å¼ç¢¼:
```c++
ostringstream:
	for(const auto& entry :people)
	{
		ostringstream formatted, badnums;
		for(cosnt auto& nums : entry.phones)
		{
			if(!valid(nums))
			{
				badnums << " " << nums;
			}
			else
			{
				formatted << " " << format(nums);
			}
		}
		if(badnums.str().empty())
			os << entry.name << " " << formatted.str() << endl;
		else
			cerr << "input error: " << entry.name << "invalid number(s) " << badnums.str() << endl;

```

## 19 å¾ªåºå®¹å™¨:
### 1. å¾ªåºå®¹å™¨å…±åˆ†ä»¥ä¸‹å¹¾ç¨®:
### vector:å¤§å°æœ‰å½ˆæ€§çš„é™£åˆ—ï¼Œæ”¯æ´å¿«é€Ÿçš„éš¨æ©Ÿå­˜å–ï¼Œä½†æ˜¯å¦‚æœè¦åœ¨å‰é¢æˆ–ä¸­é–“åšæ’å…¥æˆ–åˆªé™¤æ™‚ï¼Œé€šå¸¸æœƒæ¯”è¼ƒæ…¢ã€‚
### deque:æœ‰å…©ç«¯é–‹å£çš„ä½‡åˆ—(queue)ï¼Œæ”¯æ´å¿«é€Ÿçš„éš¨æ©Ÿå­˜å–ï¼Œåœ¨å‰ç«¯æˆ–å¾Œç«¯åšæ’å…¥è·Ÿåˆªé™¤å¾ˆå¿«ã€‚
### list:é›™å‘é€£çµä¸²åˆ—ï¼Œåªæ”¯æ´é›™å‘çš„å¾ªåºå­˜å–ï¼Œä¸è«–åœ¨å“ªåšæ’å…¥æˆ–åˆªé™¤éƒ½å¾ˆå¿«ã€‚
### forward_list:å–®å‘é€£çµä¸²åˆ—ï¼Œåªæ”¯æ´å–®å‘çš„å¾ªåºå­˜å–ï¼Œä¸è«–åœ¨å“ªåšæ’å…¥æˆ–åˆªé™¤éƒ½å¾ˆå¿«ã€‚
### array:å¤§å°æœ‰å›ºå®šçš„é™£åˆ—ï¼Œæ”¯æ´å¿«é€Ÿçš„éš¨æ©Ÿå­˜å–ï¼Œç„¡æ³•åšæ–°å¢æˆ–åˆªé™¤å…ƒç´ ã€‚
### string:ä¸€ç¨®ç‰¹åŒ–çš„å®¹å™¨ï¼Œé¡ä¼¼æ–¼vectorï¼Œè£¡é¢å­˜æ”¾çš„æ˜¯å­—å…ƒã€‚æ”¯æ´å¿«é€Ÿçš„éš¨æ©Ÿå­˜å–ï¼Œä¸”åœ¨å¾Œç«¯çš„åˆªé™¤èˆ‡æ’å…¥å¾ˆå¿«é€Ÿã€‚

### 2. ä¸€èˆ¬ä¾†èªªï¼Œæˆ‘å€‘éƒ½æ˜¯é¸æ“‡vectorä¾†ä½¿ç”¨ã€‚
### 3. å¦‚æœä½ çš„ç¨‹å¼å°å‹å…ƒç´ å¾ˆå¤šï¼Œç©ºé–“æœƒæœ‰é¡å¤–çš„è² æ“”ï¼Œé‚£å°±åˆ¥ç”¨listè·Ÿforward_listã€‚
### 4. å¦‚æœéœ€è¦åšå¿«é€Ÿçš„éš¨æ©Ÿå­˜å–ï¼Œé‚£å°±ç”¨vectorè·Ÿdequeã€‚
### 5. å¦‚æœéœ€è¦åœ¨å®¹å™¨ä¸­é–“åšæ’å…¥æˆ–åˆªé™¤ï¼Œå°±ç”¨listè·Ÿforward_list
### 6. å¦‚æœéœ€è¦åœ¨å‰ç«¯æˆ–å¾Œç«¯åšæ’å…¥è·Ÿåˆªé™¤ï¼Œå°±ç”¨dequeã€‚
### 7. è¿­ä»£å™¨ç¯„åœ:ç”±ä¸€å€‹beginè·Ÿendæ‰€çµ„æˆã€‚
### æ‰€è¬‚beginæ³›æŒ‡å®¹å™¨ä¸­çš„ç¬¬ä¸€å€‹å…ƒç´ ï¼Œè€Œendå»éå®¹å™¨ä¸­çš„æœ€å¾Œä¸€å€‹å…ƒç´ ï¼Œè€Œæ˜¯æŒ‡æœ€å¾Œä¸€å€‹å…ƒç´ çš„ä¸‹ä¸€å€‹ä½ç½®ã€‚
### 8. é€™ä»£è¡¨è‘—æˆ‘å€‘çš„å®¹å™¨æ˜¯ä¸€å€‹å·¦é–‰å³é–‹(left-inclusive intreval)çš„é™£åˆ—:[begin,end)ã€‚
### 9. æ›å¥è©±èªªï¼Œæˆ‘å€‘å¯ä»¥é€šé++beginçš„æ–¹å¼ä¾†æŠµé”endã€‚
### 10. å¦‚æœbegin = endé‚£å°±ä»£è¡¨è‘—é€™å€‹å®¹å™¨æ˜¯ç©ºçš„ã€‚
### 11. å¦‚æœbegin != endé‚£å°±ä»£è¡¨è‘—é€™å€‹å®¹å™¨ä¸­é–“è‡³å°‘æœ‰ä¸€å€‹å…ƒç´ ã€‚
### 12. è¿­ä»£å™¨çš„å‹åˆ¥å¦‚ä¸‹:
```c++
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 - a.begin(); //list<string>::iterator
auto it2 - a.rbegin(); //list<string>::reverse_iterator
auto it3 - a.cbegin(); //list<string>::const_iterator
auto it4 - a.crbegin(); //list<string>::const_reverse_iterator
```
### 13. å¦‚æœä¸éœ€è¦å¯«å…¥çš„è©±ï¼Œå°±ä½¿ç”¨cbegin()è·Ÿcend()ã€‚
### 14. å®šç¾©å’Œåˆå§‹åŒ–å®¹å™¨:
```c++
C c1(c2) //c1=c2
C c(begin, end) //cæ˜¯ç”±begin~endç¯„åœå…§æ‰€æœ‰å…ƒç´ æ‹·è²æ‰€çµ„æˆçš„ï¼Œä½†ä¸åŒ…å«endã€‚
deque<string> c2(c1.begin(), c1.end());
C seq(n) //seqæœ‰nå€‹å‹åˆ¥ç‚ºcçš„å…ƒç´ 
C seq(n,t) //seqæœ‰nå€‹å‹åˆ¥ç‚ºcçš„t
```
### 15. arrayçš„åˆå§‹åŒ–èˆ‡å®šç¾©:
```c++
array<int, 42> a1//å­˜æ”¾42å€‹intçš„array:a1
```
### 16. è¦è¨˜å¾—é™£åˆ—ä¸èƒ½è¢«æ”¾åœ¨å³å€¼ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½è¢«æ‹·è²æˆ–æŒ‡å®šçµ¦å…§å»ºé™£åˆ—ã€‚
### 17. ä½†æ˜¯å®¹å™¨arrayå»å¯ä»¥æ‹·è²æˆ–æŒ‡å®šçµ¦å®¹å™¨arrayï¼Œå¦‚ä¸‹:
```c++
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs[10]; //éŒ¯çš„å› ç‚ºé™£åˆ—ä¸èƒ½è¢«æ‹·è²æˆ–æŒ‡å®šçµ¦å…§å»ºé™£åˆ—
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits; //å¯ä»¥ï¼Œåªè¦å‹åˆ¥æ˜¯ä¸€æ¨£çš„å°±è¡Œäº†
```
### 18. åªè¦å‹åˆ¥ç›¸åŒï¼Œç¶“éæŒ‡å®šä¹‹å¾Œï¼Œå®¹å™¨çš„å¤§å°æœƒè®Šå¾—è·Ÿå³å€¼ä¸€æ¨£ã€‚
```c++
c1 = c2; //ç›´æ¥æŠŠc2æ‹·è²çµ¦c1
c1 = {a,b,c}; //c1ç¾åœ¨æ˜¯ä¸€å€‹å¤§å°ç‚º3çš„å®¹å™¨ï¼Œè£¡é¢è£{a,b,c}
```
### 19. arrayä¹ŸåŸºæœ¬æ”¯æŒä¸Šé¢çš„å„é¡æŒ‡å®šæ¨¡å¼ï¼Œä½†å»ä¸æ”¯æŒä»¥ä¸‹é€™ç¨®:
```c++
a = {0}; //æˆ‘å€‘æ²’è¾¦æ³•ç›´æ¥å°arrayåšassignï¼Œå› ç‚ºå®ƒå¯èƒ½èˆ‡å®ƒä¸€é–‹å§‹çš„å®£å‘Šçš„å¤§å°ä¸åŒã€‚
```
### 20. å¦‚åŒæˆ‘å€‘å‰é¢æ‰€èªªï¼Œarrayç„¡æ³•åšæ’å…¥èˆ‡åˆªé™¤ï¼Œå› æ­¤æ‰€æœ‰å¯èƒ½å°è‡´å¤§å°ä¸åŒçš„é‹ç®—éƒ½æ˜¯ä¸æ”¯æ´çš„ã€‚
### 21. æˆ‘å€‘ä¹Ÿå¯ä»¥é€šéswapçš„æ–¹å¼ä¾†äº¤æ›c1è·Ÿc2ï¼Œè€Œä¸”é€™é€šå¸¸æ¯”æ‹·è²é‚„è¦å¿«ã€‚
```c++
swap(c1,c2);
c1.swap(c2);
```
### 22. ä½†è¦è¨˜å¾—ï¼Œé‚„æ˜¯éœ€è¦ç›¸åŒå‹åˆ¥æ‰èƒ½ä½¿ç”¨é€™äº›é‹ç®—ã€‚
### 23. ä¹Ÿæœ‰é—œæ–¼assignçš„å‡½å¼:
```c++
seq.assign(c.begin(), c.end()); //å°‡cå¾beginåˆ°endæ”¾åˆ°seqè£¡é¢
seq.assign(n,t) //å°‡nå€‹tæ”¾é€²squè£¡é¢
seq.assign(il); //ç›´æ¥å°‡ä¸²åˆ—ilå–ä»£seq
```
### 24. assignå°±å¤šæ¨£åŒ–ä¸€é»ï¼Œå®ƒä¸ä¸€å®šè¦ç›¸åŒå‹åˆ¥ï¼Œåªè¦ç›¸å®¹çš„è©±ï¼Œä¹Ÿèƒ½åšé‹ç®—ï¼Œå¦‚ä¸‹:
```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; //éŒ¯çš„ï¼Œä¸æ˜¯ç›¸åŒå‹åˆ¥
names.assugn(oldstyle.cbegin(), oldstyle.cend()) //å¯ä»¥å› ç‚ºcharèˆ‡stringç›¸å®¹
```
### 25. å“ªæ€•ç¶“éäº†swapï¼Œå®¹å™¨çš„è¿­ä»£å™¨ã€åƒè€ƒï¼Œèˆ‡æŒ‡æ¨™éƒ½ä¸æœƒç„¡æ•ˆåŒ–ã€‚
### é€™ä»£è¡¨è‘—å“ªæ€•ç¶“éswapï¼Œè¿­ä»£å™¨ã€åƒè€ƒï¼Œèˆ‡æŒ‡æ¨™ä»ç„¶ç¶å®šåœ¨å®ƒå€‘åŸä¾†ç¶å®šçš„å…ƒç´ ä¸Šï¼Œåªæ˜¯å…ƒç´ æ‰€ä»£è¡¨çš„å€¼ä¸ä¸€æ¨£äº†ã€‚
```c++
swap(c1,c2) //å‡å®šäº¤æ›c1è·Ÿc2
```
### å‡å®šç¾åœ¨æˆ‘å€‘äº¤æ›äº†c1è·Ÿc2ï¼Œé‚£éº¼c1[2]çš„ä½å€é‚„æ˜¯æ²’è®Šï¼Œåªæ˜¯å…¶å…§éƒ¨æ‰€å«çš„å€¼æ”¹è®Šäº†ã€‚
### 26. å®¹å™¨æ”¯æ´å¤§å°æ¯”è¼ƒ:
```c++
vector<int> v1 = {1,3,5,7,9,12};
vector<int> v2 = {1,3,9};
vector<int> v3 = {1,3,5,7};
vector<int> v4 = {1,3,5,7,9,12};
```
### v1 < v2:æˆç«‹ï¼Œå› ç‚ºv2[2] > v1[2]
### v1 < v3:éŒ¯ï¼Œå› ç‚ºå‰é¢å››å€‹å…ƒç´ éƒ½ç›¸ç­‰ï¼Œé‚£éº¼å°±æ¯”å¤§å°ã€‚é€™åŒæ¨£ä»£è¡¨v3æ˜¯v1çš„å­åºåˆ—(subsequence)
### v1 == v4:æˆç«‹ï¼Œé€™ç„¡åº¸ç½®ç–‘çš„ï¼Œå…©å€‹ä¸€æ¨¡ä¸€æ¨£ã€‚
### 27. ä½†æˆ‘å€‘ä¹Ÿè¦è¨˜å¾—ï¼Œå®¹å™¨ä¹‹æ‰€ä»¥æ”¯æ´å¤§å°æ¯”è¼ƒï¼Œé‚£æ˜¯å› ç‚ºå…¶å…§éƒ¨æ‰€è£çš„ç‰©ä»¶(int,double,string,float)ä¹ŸåŒæ¨£æ”¯æ´ã€‚
### 28. ç•¶æˆ‘å€‘ä½¿ç”¨ä¸€å€‹ç‰©ä»¶ä¾†åˆå§‹åŒ–åˆæˆ–è€…æ’å…¥åˆ°ä¸€å€‹å®¹å™¨æ™‚ï¼Œå…¶æœ¬è³ªå°±æ˜¯æ‹·è²ï¼Œèˆ‡è©²ç‰©ä»¶æœ¬é«”ä¸¦æ²’æœ‰é—œä¿‚ã€‚
### 29. é™¤äº†push_back()ä¹‹å¤–ï¼Œlistã€forward_listè·Ÿdequeé‚„æ”¯æ´äº†push_front()ï¼Œç”¨ä¾†å°‡ç‰©ä»¶æ’å…¥åˆ°å®¹å™¨çš„å‰ç«¯ã€‚
### 30. æˆ‘å€‘ä¹Ÿå¯ä»¥ä½¿ç”¨insertåœ¨å®¹å™¨çš„ä»»ä¸€ä½ç½®é€²è¡Œæ’å…¥:
```c++
c.insert(p, t)  //åœ¨è¿­ä»£å™¨(ä½ç½®)pä¹‹å‰æ’å…¥å€¼ç‚ºtçš„å…ƒç´ ï¼Œä¸¦å›å‚³æŒ‡å‘Pä¸Šä¸€å€‹å…ƒç´ çš„è¿­ä»£å™¨
c.insert(p, n, t)  //åœ¨è¿­ä»£å™¨(ä½ç½®)pä¹‹å‰æ’å…¥nå€‹å€¼ç‚ºtçš„å…ƒç´ 
c.insert(p, begin(), end())  //åœ¨è¿­ä»£å™¨(ä½ç½®)pä¹‹å‰æ’å…¥ç¯„åœbeginåˆ°endä¸­é–“çš„æ‰€æœ‰å…ƒç´ ï¼Œä½†é‚„æ˜¯è¦è¨˜å¾—ï¼Œä¸åŒ…å«end
c.insert(p, il) //åœ¨è¿­ä»£å™¨(ä½ç½®)pä¹‹å‰æ’å…¥il(ä¸²åˆ—)
```
### 31. ä½†è¦è¨˜å¾—ï¼Œèˆ‡swapä¸åŒçš„æ˜¯ï¼Œä¸€ä½†æˆ‘å€‘æ–°å¢å…ƒç´ åˆ°ä¸€å€‹å®¹å™¨ä¸­ï¼Œé‚£éº¼å®ƒåŸä¾†çš„è¿­ä»£å™¨ã€åƒè€ƒï¼Œèˆ‡æŒ‡æ¨™å°±éƒ½æœƒç„¡æ•ˆåŒ–äº†ã€‚
### 32. é›–ç„¶æœ‰äº›å®¹å™¨ä¸æ”¯æ´push_frontï¼Œä½†insertå»æ²’æœ‰é™åˆ¶ï¼Œå¤§å®¶éƒ½èƒ½ç”¨ã€‚
### é€™ä¹Ÿå°±ä»£è¡¨æˆ‘å€‘å¯ä»¥ä½¿ç”¨insertåœ¨vectorå‰ç«¯æ’å…¥ä¸€å€‹å…ƒç´ ï¼Œä½†é€™å¾€å¾€ä¹Ÿæ„å‘³è‘—æˆ‘å€‘çš„æ•ˆèƒ½æœƒå¤§å¹…é™ä½ã€‚å› ç‚ºvectoræœ¬èº«å…¶å¯¦å°±ä¸é©åˆåœ¨å‰ç«¯åšæ’å…¥æˆ–åˆªé™¤ã€‚
### 33. emplaceå‡½å¼ï¼Œèˆ‡push/insertä¸åŒï¼Œemplaceæ˜¯çœŸçš„åœ¨ç©ºé–“å…§å‰µå»ºäº†ä¸€å€‹ç‰©ä»¶ç„¶å¾Œæ”¾é€²å®¹å™¨è£¡ï¼Œä¸¦éæ˜¯æ‹·è²ã€‚
```c++
c.emplace_back("978-0590353403", 25, 15.99); //å‡è¨­æˆ‘å€‘æœ‰ä¸€å€‹Sales_dataç‰©ä»¶çš„å»ºæ§‹å™¨ï¼Œé‚£éº¼å°±æ˜¯å‰µé€ ä¸€å€‹Sales_dataå‹åˆ¥çš„ç‰©ä»¶æ”¾åˆ°cçš„å¾Œç«¯ã€‚
c.emplace_back(Sales_data("978-0590353403", 25, 15.99));
```
### é€™å°±ä»£è¡¨è‘—emplaceå‡½å¼ä¸­çš„åƒæ•¸(å¼•è¿°)ï¼Œå¿…é ˆè·Ÿç¨‹å¼å…§éƒ¨çš„æŸä¸€å€‹å»ºæ§‹å™¨ç›¸åŒ¹é…ã€‚
### 34. åœ¨æ“ä½œä¸€å€‹å®¹å™¨ä¹‹å‰ï¼Œæˆ‘å€‘ä¸€å®šè¦ç¿’æ…£å…ˆæª¢æŸ¥å®ƒå…§éƒ¨æ˜¯å¦æœ‰å…ƒç´ ï¼Œæœ€ç°¡å–®çš„æ–¹æ³•æ˜¯:
```c++
if(!c.empty())
{
}
```
### 35.foward_listä¸æ”¯æ´éæ¸›(--)è·Ÿbackã€‚
### 36. å­˜å–å®¹å™¨ä¸­çš„å…ƒç´ :
```c++
c.back() //èˆ‡endä¸åŒï¼Œé€™æ˜¯å–æœ€å¾Œä¸€å€‹å…ƒç´ ã€‚
c.front() //ç¬¬ä¸€å€‹å…ƒç´ 
c[n] //ç¬¬nå€‹å…ƒç´ 
c.at(n) //ç¬¬nå€‹å…ƒç´ ï¼Œä½†å¦‚æœéŒ¯èª¤çš„è©±ï¼Œå°±æœƒå›å‚³out_of_range
```
### é€™ä¹Ÿæ˜¯ç‚ºç”šéº¼æˆ‘å€‘è¦å…ˆæª¢æŸ¥å®¹å™¨æ˜¯å¦ç‚ºç©ºçš„åŸå› ï¼Œå› ç‚ºæˆ‘å€‘æ˜¯ä½¿ç”¨ä¸‹æ¨™çš„æ–¹å¼ä¾†å­˜å–ã€‚å¦‚æœæ²’æœ‰å…ƒç´ åœ¨å®¹å™¨å…§ï¼Œé€™å°±ä»£è¡¨è‘—æˆ‘å€‘è¶…å‡ºç¯„åœäº†ã€‚
### 37. æˆ‘å€‘å­˜å–å®¹å™¨ä¸­çš„å…ƒç´ ï¼Œå…¶å¯¦å°±ç­‰æ–¼å›å‚³è©²å…ƒç´ çš„åƒè€ƒã€‚å¦‚æœæˆ‘å€‘åœ¨å»ºæ§‹å‡½å¼ä¸€æ¨£ï¼Œå¦‚æœå®¹å™¨æ˜¯consté‚£å°±å›å‚³const&ï¼Œå¦‚æœä¸æ˜¯ï¼Œé‚£å°±æ˜¯æ­£å¸¸çš„referenceï¼Œæ˜¯å¯ä»¥åšæ”¹è®Šçš„ã€‚
### 38. ç§»é™¤å…ƒç´ :
```c++
c.pop_back() //ç§»é™¤å®¹å™¨cä¸­çš„æœ€å¾Œä¸€å€‹å…ƒç´ 
c.pop_back() //ç§»é™¤å®¹å™¨cä¸­çš„ç¬¬ä¸€å€‹å…ƒç´ 
c.erase(p) //ç§»é™¤è¿­ä»£å™¨pï¼Œä¹Ÿå°±æ˜¯ä½ç½®pçš„å…ƒç´ ï¼Œä¸¦ä¸”å›å‚³ä¸‹ä¸€å€‹å…ƒç´ 
c.erase(begin,end) //ç§»é™¤è¿­ä»£å™¨beginåˆ°endä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œç•¶ç„¶ä¸åŒ…å«endã€‚åŒæ™‚å›å‚³ä¸€å€‹æŒ‡é‡ï¼ŒæŒ‡å‘endï¼Œåˆæˆ–è€…èªªæŒ‡å‘è¢«ç§»é™¤å…ƒç´ å¾Œçš„ä¸‹ä¸€å€‹å…ƒç´ ã€‚
c.clear() //ç§»é™¤cä¸­çš„æ‰€æœ‰å…ƒç´ 
```
## ç·´ç¿’é¡Œ17
### è¨­è¨ˆä¸€å€‹ç¨‹å¼ï¼Œå¯ä»¥è®“ä½¿ç”¨è€…è¼¸å…¥ä¸€ä¸²æ•¸åˆ—ï¼ŒåŒæ™‚å¯ä»¥æ±ºå®šè¦åˆªé™¤æ•¸åˆ—ä¸­çš„å“ªä¸€å€‹æ•¸å­—ã€‚
```c++
#include <iostream>
#include <string>
#include <vector>
int main()
{
begin:
	std::vector<int> nums; //the vector for user to stroe the numbers what they input
	int val = 0; //the varibale to store the input numbers
	int counter = 0; //the counter to count how many variables the user already input
	while (counter < 10 && std::cin >> val)
	{
		nums.push_back(val);
		++counter;
	}
	std::string YesOrNo = "";
	//check if the vector is empty or not
	if (nums.empty())
	{
		std::cerr << "No numbers in the vector now." << std::endl;
		std::cout << "Do you want to try again?(Yes or Np)" << std::endl;

		std::cin >> YesOrNo;
		if (YesOrNo == "yes" || YesOrNo == "Yes")
		{
			goto begin;
		}
		else
		{
			return -1;
		}
	}
	//print the variables in the vector
	std::cout << "The numbers you input are: " << std::flush;
	for (auto& v : nums)
	{
		std::cout << v << ", " << std::flush;
	}
	std::cout << "\n" << "Please enter what numbers you want to erase?" << std::endl;
	int era_val = 0;
	auto beg = nums.begin(); //iterator begin
	bool findornot = false; 
	//check if the input is valid or not
	if (std::cin >> era_val)
	{
		while (beg < nums.end()) //search the variable from begin to end
		{
			if (era_val == *beg) //find
			{
				nums.erase(beg);
				findornot = true;	
				break;
			}
			else //not find and increase the iterator
			{
				++beg;
			}
		}
	}
	else
	{
		std::cout << "Invalid Input." << std::endl;
	}
	//check if we find the variable or not
	if (findornot)
	{
		std::cout << "The numbers are: " << std::flush;
		//print the varibales after we erase the target
		for (auto& v : nums)
		{
			std::cout << v << ", " << std::flush;
		}
		return 0;
	}
	else
	{
		std::cout << "The number you want to erase is not in the vector." << std::endl;
		return -1;
	}
}
```
### 39. å°æ–¼forward_listçš„æ’å…¥æˆ–åˆªé™¤:
```c++
lst.before_begin() //å›å‚³ä¸²åˆ—é–‹é ­å‰é‚£å€‹ä¸å­˜åœ¨çš„å…ƒç´ ï¼Œä»¥ä¾¿ä¹‹å¾Œç”¨ä¾†æ–°å¢è·Ÿåˆªé™¤ã€‚
lst.cbefore_begin() //å›å‚³ä¸²åˆ—é–‹é ­å‰é‚£å€‹ä¸å­˜åœ¨çš„å…ƒç´ ï¼Œä½†æ˜¯constï¼Œä»¥ä¾¿ä¹‹å¾Œç”¨ä¾†æ–°å¢è·Ÿåˆªé™¤ã€‚
lst.insert_after(p,t) //åœ¨è¿­ä»£å™¨pä¹‹å¾Œæ’å…¥ç‰©ä»¶tã€‚
lst.insert_after(p,n,t) //åœ¨è¿­ä»£å™¨pä¹‹å¾Œæ’å…¥nå€‹ç‰©ä»¶tã€‚
lst.insert_after(p,begin,end) //åœ¨è¿­ä»£å™¨pä¹‹å¾Œæ’å…¥è¿­ä»£å™¨beginåˆ°endä¸­é–“çš„ç‰©ä»¶ï¼Œç•¶ç„¶ä¸€æ¨£ä¸åŒ…å«endã€‚
lst.insert_after(p,il) //åœ¨è¿­ä»£å™¨pä¹‹å¾Œæ’å…¥ä¸²åˆ—ilã€‚
lst.erase_after(p) //ç§»é™¤è¿­ä»£å™¨pä¹‹å¾Œæ‰€ä»£è¡¨å…ƒç´ çš„å€¼ï¼Œä¸¦å›å‚³æŒ‡æ¨™æŒ‡å‘ä¸‹ä¸€å€‹å…ƒç´ 
lst.erase_after(begin,end) //ç§»é™¤è¿­ä»£å™¨beginä¹‹å¾Œåˆ°endä¸­é–“çš„ç‰©ä»¶ï¼Œç•¶ç„¶ä¸€æ¨£ä¸åŒ…å«endï¼Œæ˜¯æœƒå›å‚³æŒ‡æ¨™æŒ‡å‘endã€‚
```
### 40. ç•¶æˆ‘å€‘è¦å°ä¸€å€‹forward_liståšæ’å…¥æˆ–åˆªé™¤ï¼Œä¸€å®šè¦è¨˜å¾—è¿½è¹¤å…©å€‹è¿­ä»£å™¨:
### ä¸€å®šè¦è¨˜å¾—å®£å‘Šé–‹é ­å‰å…ƒç´ ï¼Œå› ç‚ºforward_listæ˜¯å–®å‘çš„ï¼Œæˆ‘å€‘åˆªé™¤çš„æ¯ä¸€å€‹å…ƒç´ éƒ½æœƒå¼•éŸ¿å‰ä¸€å€‹å…ƒç´ ï¼Œå› æ­¤æˆ‘å€‘éœ€è¦ä½¿ç”¨å‰ä¸€å€‹å…ƒç´ ä¾†åšæ’å…¥èˆ‡åˆªé™¤ï¼Œé€™ä¹Ÿä»£è¡¨è‘—å®£å‘Šé–‹é ­å‰å…ƒç´ æ˜¯å¿…ç„¶çš„ã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
forward_list<int> flst = {0,1,2,3,4,5,6,7,8,9};
auto prev = flst.before_begin();
auto curr = flst.begin();
while(curr != flst.end())
{
	if(*curr % 2) //å¥‡æ•¸
	{
		curr = flst.erase_after(prev);
	}
	else
	{
		prev = curr; //é–‹å§‹å‘å¾Œç§»å‹•å°‹æ‰¾
		++curr;
	}
}
```
### 41. resizeå‡½å¼:ç”¨ä¾†èª¿æ•´vectorçš„å¤§å°ã€‚
```c++
list<int> ilist(10,42); //è£æœ‰10å€‹intç‰©ä»¶ï¼Œå…ƒç´ å€¼éƒ½æ˜¯10
ilist.resize(15); //å‘å¾Œæ–°å¢5å€‹å…ƒç´ å€¼ç‚º0çš„ç‰©ä»¶
ilist.resize(25,-1); //å‘å¾Œæ–°å¢10å€‹å…ƒç´ å€¼ç‚º-1çš„ç‰©ä»¶
ilist.resize(5); //å¾å¾Œç«¯åˆªé™¤20å€‹å…ƒç´ 
```
### 42. è¦æ³¨æ„ï¼Œarrayä¸èƒ½resizeã€‚
### 43. ä¸€å®šè¦è¨˜å¾—ï¼Œç•¶æˆ‘å€‘å°å®¹å™¨åšæ–°å¢ä»¥åŠåˆªé™¤ä¹‹å¾Œï¼Œçµ•å¤§å¤šæ•¸çš„è¿­ä»£å™¨ã€æŒ‡æ¨™ï¼Œä»¥åŠåƒè€ƒéƒ½ç„¡æ•ˆåŒ–äº†ï¼Œé€™ä»£è¡¨è‘—æˆ‘å€‘ä¸èƒ½å†ä½¿ç”¨å®ƒï¼Œè«‹é‡æ–°å®£å‘Šã€‚
### 44. é€™ä¹Ÿå°±ä»£è¡¨è‘—æˆ‘å€‘å¿…é ˆä¸æ–·çš„æ›´æ–°è¿­ä»£å™¨:
## ç·´ç¿’é¡Œ18
```c++
//ç§»é™¤å¶æ•¸ä¸¦ä¸”è¤‡è£½å¥‡æ•¸
int main()
{
	std::vector<int> vi = { 0,1,2,3,4,5,6,7,8,9 };
	auto iter = vi.begin();
	while (iter != vi.end())
	{
		if (*iter % 2) //å¥‡æ•¸
		{
			iter = vi.insert(iter, *iter);
			iter += 2; //å› ç‚ºåŸä¾†æ˜¯è¦æŒ‡å‘ä¸‹ä¸€å€‹å…ƒç´ (+1)ï¼Œä½†æˆ‘å€‘ç¾åœ¨åœ¨iterå‰é¢é¡å¤–æ’å…¥äº†ä¸€å€‹å…ƒç´ ï¼Œæ‰€ä»¥è®Šæˆ+2
		}
		else
		{
			iter = vi.erase(iter); //ç§»é™¤iteræ‰€ä»£è¡¨çš„å…ƒç´ ï¼Œä¸¦ä¸”å›å‚³ä¸‹ä¸€å€‹å…ƒç´ ï¼Œæ‰€ä»¥ä¸ç”¨åšæ”¹è®Š
		}
	}
	for (auto& v : vi)
	{
		std::cout << v << std::flush;
	}
	return 0;
}
```
### 45. ä¸è¦å°‡end()å®šç¾©åœ¨ä¸€å€‹è®Šæ•¸å…§ï¼Œå› ç‚ºæˆ‘å€‘æ¯æ¬¡åšæ–°å¢æˆ–ç§»é™¤æ˜¯ï¼Œè¿­ä»£å™¨å°±ç™¼ç”Ÿæ”¹è®Šäº†ï¼Œæˆ‘å€‘æ‡‰è©²ç¢ºä¿æ¯ä¸€æ¬¡çš„endéƒ½æœƒå†è¿´åœˆå…§åšæ›´æ–°ã€‚
### 46. å®¹å™¨çš„å¤§å°ç®¡ç†:
```c++
c.shrunk_to_fit() //è«‹æ±‚å°‡capcityé™åˆ°è·Ÿsizeä¸€æ¨£çš„å¤§å°
c.capacity() //é‡æ–°é…ç½®å‰cæ‰€å¯ä»¥å®¹ç´çš„å…ƒç´ é‡  ä¹Ÿå°±æ˜¯ç¨‹å¼çœŸçš„é‹ä½œèµ·ä¾†å¾Œï¼Œæ‰çŸ¥é“è©²å®¹å™¨åˆ°åº•å¤šå¤§
c.reserve(n) //ç‚ºè‡³å°‘nå€‹å…ƒç´ é…ç½®ç©ºé–“
```
### æ‰€ä»¥æˆ‘å€‘å¯ä»¥é€šécapacityèˆ‡sizeçš„äº’å‹•ä¾†ä½¿ç”¨æˆ‘å€‘çš„ç©ºé–“:
```c++
while(ivec.size() != ivec.capacity())
{
	ivec.push_back(0);
}
```
### 47. é€™ç¨®åˆ†é…ç©ºé–“çš„æ–¹å¼å«åšvectorå¯¦ä½œï¼Œå®ƒå€‘éƒ½æœƒè‡ªå·±å®šç¾©capacityå¤§å°çš„æœ€ä½³ç­–ç•¥ã€‚
### 48. stringçš„ç‰¹æ®Šå»ºæ§‹å¼:
```c++
string s(cp,n); //cpæ‰€æŒ‡é™£åˆ—çš„å‰nå€‹å­—å…ƒçš„æ‹·è²
string s(s2,pos2); //å­—ä¸²s2å¾pos2é–‹å§‹å¾Œé¢æ‰€æœ‰å…ƒç´ çš„ä¸€å€‹æ‹·è²
string s(s2,pos2,len2); //å­—ä¸²s2å¾pos2é–‹å§‹å¾Œé¢len2å€‹å…ƒç´ çš„ä¸€å€‹æ‹·è²
```
### 49. ä¸€èˆ¬ä¾†èªªç•¶æˆ‘å€‘ä»¥ä¸€å€‹æŒ‡æ¨™ä¾†å®£å‘Šå­—ä¸²ï¼Œé‚£é€™å€‹æŒ‡æ¨™æ‰€æŒ‡çš„å­—ä¸²é™£åˆ—å°±å¿…ç„¶ä»¥nullçµå°¾ã€‚
```c++
const char *cp = "Hello World!";
```
### 50. substrå‡½å¼:
```c++
string s("hello world");
string s2 = s.substr(0, 5); //så¾é›¶é–‹å§‹æ•¸äº”å€‹ å°å‡ºhello
string s2 = s.substr(6); //åˆå§‹å€¼é è¨­ç‚º0 å°å‡ºå…­å€‹
```
### 51. ä¿®æ”¹string:
```c++
s.insert(s.size(), 5, '!'); //åœ¨æœ€å¾Œé¢ï¼Œä¹Ÿå°±æ˜¯endå‰æ’å…¥äº”å€‹é©šå˜†è™Ÿ
s.erase(s.size() - 5, 5); //ç§»é™¤æœ€å¾Œäº”å€‹å­—å…ƒ
const char *cp = "Stately, plump Buck";
s.assign(cp, 7); //cpæ‰€æŒ‡æŒ‡å‘å­—å…ƒé–‹å§‹çš„ä¸ƒå€‹å­—å…ƒ
```
### 52. appendèˆ‡replaceå‡½å¼:
```c++
s2.append("4th Ed.") //ç­‰æ–¼å°‡"4th Ed."é™„åŠ åˆ°s2ä¸Šï¼Œä¸¦ä¸”å›å‚³ä¸€å€‹æ–°çš„s2åƒè€ƒ
s2.replace(11, 3, "5th"); //ç­‰æ–¼å°‡å¾11å¾Œé¢ä¸‰å€‹å­—å…ƒæ›¿æ›ç‚º"5th"
```
### 53. stringçš„æœå°‹é‹ç®—:
```c++
s.find(args) //åœ¨sä¸­æ‰¾å‡ºargsç¬¬ä¸€å€‹å‡ºç¾è™•
s.rfind(args) //åœ¨sä¸­æ‰¾å‡ºargsæœ€å¾Œä¸€å€‹å‡ºç¾è™•
s.find_first_of(args) //åœ¨sä¸­æ‰¾å‡ºargsä¸­ä»»ä½•å­—å…ƒçš„ç¬¬ä¸€å€‹å‡ºç¾è™•
s.find_last_of(args) //åœ¨sä¸­æ‰¾å‡ºargsä¸­ä»»ä½•å­—å…ƒçš„æœ€å¾Œä¸€å€‹å‡ºç¾è™•
s.find_first_not_of(args) //åœ¨sä¸­æ‰¾å‡ºä¸åœ¨argsä¸­ä»»ä½•å­—å…ƒçš„ç¬¬ä¸€å€‹å‡ºç¾è™•
s.find_last_not_of(args) //åœ¨sä¸­æ‰¾å‡ºä¸åœ¨argsä¸­ä»»ä½•å­—å…ƒçš„æœ€å¾Œä¸€å€‹å‡ºç¾è™•
```
### è¨»è¨˜:(args)ä»£è¡¨:
### ('c', pos):å¾posé–‹å§‹æ‰¾å­—å…ƒc
### (s, pos):å¾posé–‹å§‹æ‰¾å­—ä¸²s
### (cp, pos):å¾posé–‹å§‹æ‰¾æŒ‡æ¨™cpæ‰€æŒ‡å‘çš„å­—ä¸²
### (cp, pos, n):å¾posé–‹å§‹æ‰¾æŒ‡æ¨™cpæ‰€æŒ‡å‘å­—ä¸²çš„å‰nå€‹å­—å…ƒ
## ç·´ç¿’é¡Œ19
```c++
//å°‹æ‰¾å­—å…ƒ
int main()
{
	std::string s = "";
	char c;
	std::string::size_type pos = 0;
	std::cout << "Please enter a sentence or a word." << std::endl;
	if (getline(std::cin, s))
	{
		std::cout << "Please enter the character you want to find: " << std::flush;
		std::cin >> c;
		auto index = s.find(c, pos);
		if (index != -1) //find
		{
			std::cout << "The character " << c << " is at index: " << index << std::endl;
			return 0;
		}
		else
		{
			std::cout << "The character is not in this string. "<< std::endl;
			return 0;
		}
	}
	else
	{
		std::cerr << "Invalid Input." << std::endl;
		return -1;
	}
}
```
## ç·´ç¿’é¡Œ20
```c++
//æ‰¾å‡ºæ•¸å­—ä¸¦ä¸”åšå‡ºè½‰æ›
#include <iostream>
#include <string>
#include <sstream>
int main()
{
	std::string s = "";
	std::string::size_type pos = 0;
	std::string numbers = "-0123456789";
	std::cout << "Please enter the senetence: " << std::endl;
	if (getline(std::cin, s)) //è¼¸å…¥å¥å­
	{	
		std::cout << "the numbers are: " << std::flush;
		while (s.find_first_of(numbers) != std::string::npos) //å¦‚æœæœ‰æ‰¾åˆ°æ•¸å­—
		{
			double d = stod(s.substr(s.find_first_of(numbers))); //å¾ç¬¬ä¸€å€‹æ•¸å­—çš„ä½ç½®é–‹å§‹è½‰æ›ï¼Œç›´åˆ°ä¸æ˜¯æ•¸å­—ç‚ºæ­¢
			std::cout << d << " " << std::flush;
			std::ostringstream strStream;
			strStream << d; //å°‡dè½‰ç‚ºstring
			//std::cout << strStream.str().size() << std::endl;
			//std::cout << "There are " << strStream.str().size() << " numbers" << std::endl;
			if (s.find_first_of(numbers) == 0)
			{
				s.erase(s.find_first_of(numbers), strStream.str().size());
				//std::cout << "Now: " << s << std::endl;
			}
			else
			{
				s.erase(pos, s.find_first_of(numbers) + strStream.str().size());
				//std::cout << "Now: " << s << std::endl;
			}		
		}
	}
	return 0;
}

```
### 54. å®¹å™¨è½‰æ¥å™¨:stack, queue, priority_queue
### æ¯å€‹è½‰æ¥å™¨éƒ½å®šç¾©äº†å…©å€‹å»ºæ§‹å™¨ï¼Œä¸€å€‹ç”¨ä¾†å‰µå»ºç©ºç‰©ä»¶ï¼Œé‚„æœ‰ä¸€å€‹ç”¨ä¾†æ¥å—å®¹å™¨ã€‚
### é»˜èªæƒ…æ³ä¸‹ï¼Œstackè·Ÿqueueéƒ½æ˜¯åŸºæ–¼dequeå¯¦ç¾çš„ã€‚è€Œpriority_queueå‰‡æ˜¯åœ¨vectorä¸Šå¯¦ç¾ã€‚
```c++
stack<int> stk(deq); //å°‡deqè£¡é¢çš„å…ƒç´ æ‹¿å‡ºä¾†å­˜åˆ°stkè£¡é¢
```
### 55. stackå­˜æ”¾æ–¼stackçš„æ¨™é ­æª”ä¸­ï¼ŒåŒæ™‚ä¹Ÿç‚ºæ–¼æ¨™æº–å‡½å¼åº«ä¸­ã€‚
```c++
int main()
{
	std::stack<int> intstack;
	for (size_t ix = 0; ix != 10; ++ix)
	{
		intstack.push(ix); //å¾0æ”¾åˆ°9
	}
	while (!intstack.empty()) 
	{
		int value = intstack.top(); //æœ€é ‚ç«¯ç‚º9
		std::cout << value << std::endl; //å°å‡ºæœ€é ‚ç«¯çš„å€¼
		intstack.pop(); //åˆªé™¤æœ€é ‚ç«¯çš„å€¼ï¼Œä»£è¡¨å‘å‰ç§»ä¸€æ ¼
	}	
}
```
## 20 æ³›ç”¨æ¼”ç®—æ³•:
### 1. ä¸€èˆ¬ä¾†èªªï¼Œæ¼”ç®—æ³•ä¸æœƒç›´æ¥ä½œç”¨åœ¨æ•´å€‹å®¹å™¨ä¸Šï¼Œè€Œæ˜¯é€šéä¸€çµ„è¿­ä»£å™¨æ‰€ç•Œå®šçš„ç¯„åœï¼Œåœ¨ä¸Šé¢å°‹è¨ª(traverse)ï¼Œè€Œå¾Œå°æ¯ä¸€å€‹å…ƒç´ åšä¸€äº›è™•ç†ã€‚
### 2. æŒ‡æ¨™åœ¨å…§å»ºé™£åˆ—ä¸Šçš„è¡Œç‚ºå°±ç­‰åŒæ–¼è¿­ä»£å™¨ã€‚
### 3. é™¤äº†å°‘æ•¸å¹¾å€‹ä¾‹å¤–ï¼Œæ¼”ç®—å°±å°±æ˜¯ä½œç”¨æ–¼ä¸€çµ„è¿­ä»£å™¨çš„ç¯„åœå…§ï¼Œè€Œé€™å€‹ç¯„åœæˆ‘å€‘ç¨±ç‚ºè¼¸å…¥ç¯„åœ"input range"ã€‚
### 4. å¦‚æœåªæ‰“ç®—è®€å–ä¸æœƒå¯«å…¥ï¼Œè«‹å–„ç”¨cbegin()è·Ÿcend()ã€‚
### 5. ä¸€å®šè¦è¨˜å¾—ï¼Œæ¼”ç®—æ³•ä¸æœƒæ”¹è®Šå®¹å™¨å¤§å°ï¼Œå› ç‚ºå®ƒå€‘ä¸¦ä¸èƒ½ç›´æ¥åšæ’å…¥èˆ‡åˆªé™¤ã€‚
### 6. ç‚ºäº†ç¢ºä¿æˆ‘å€‘æœ‰è¶³å¤ çš„å…ƒç´ ä¾†é€²è¡Œå­˜å–ï¼Œæˆ‘å€‘å¯ä»¥ä½¿ç”¨æ’å…¥è¿­ä»£å™¨(insert iterator):
```c++
int main()
{
	std::vector<int> vec;
	auto it = back_inserter(vec); //é€šéitä¾†æ’å…¥å…ƒç´ åˆ°vecä¸­
	*it = 42;
	auto beg = vec.begin();

	while (beg != vec.end())
	{
		std::cout << *beg++ << std::endl;
	}
	return 0;
}

```
```c++
int main()
{
	std::vector<int> vec;
	auto it = back_inserter(vec);	
	fill_n(it, 10, 0);
	auto beg = vec.begin();
	while (beg != vec.end())
	{
		std::cout << *beg++ << std::endl;
	}
	return 0;
}
```
### 7. ç•¶æˆ‘å€‘æƒ³è¦ç¢ºä¿å…©å€‹é™£åˆ—å¤§å°ç›¸åŒæ™‚ï¼Œå¯ä»¥ä½¿ç”¨sizeof:
```c++
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1),end(a1),a2); //å°‡a1æ‹·è²åˆ°a2ä¸­ï¼Œä½†å‰é¡Œæ˜¯a2èˆ‡a1ä¸€æ¨£å¤§
```
### 8. å¦‚æˆ‘å€‘å‰é¢æ‰€èªªï¼Œæ¼”ç®—æ³•ä¸¦ä¸èƒ½ç›´æ¥åšæ’å…¥èˆ‡åˆªé™¤ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥é€šéä»¥ä¸‹æ–¹æ³•ä¾†æ”¹è®Šå®¹å™¨:
```c++
void Elim_Dups(std::vector<std::string> sen)
{

	sort(sen.begin(), sen.end());
	auto the_unique = unique(sen.begin(), sen.end()); //covert the repeat_words to null and move them to the end(after the last element)
	//but the size of the vector isnt changed
	sen.erase(the_unique, sen.end()); //erase the null from the_unique(after the last not null element) to end(before the end)
	for (auto& beg : sen)
	{
		std::cout << beg << " " << std::flush;
	}
}
void Elim_Dups(std::vector<std::string>);
int main()
{
	std::vector<std::string> sentences;
	std::string word = "";
	while (std::cin >> word) //press ctrl+z to stop
	{
		sentences.push_back(word);
	}
	Elim_Dups(sentences);
	return 0;
}
```
### è¨»è¨˜:uniqueåªèƒ½è™•ç†ç›¸é„°çš„é‡è¤‡å…ƒç´ ï¼Œæ‰€ä»¥ä½¿ç”¨å‰å¿…ç„¶è¦å…ˆé€²è¡Œæ’åºã€‚
### 9. å¯å‘¼å«ç‰©ä»¶(Callable Objects):Lambda Expressionï¼Œå¯ä»¥æŠŠå®ƒæƒ³æˆæ˜¯ä¸€å€‹æ²’æœ‰å‘½åçš„inlineå‡½å¼ã€‚
	[capture list] (parameter list) -> return type {function body}
 	//parameter listè·Ÿreturn typeæ˜¯å¯ä»¥çœç•¥çš„
### ç¯„ä¾‹ç¨‹å¼:
```c++
//æ¯”è¼ƒå­—è©é•·çŸ­ä¸¦é‡æ–°æ’åº
void Elim_Dups(std::vector<std::string>);
bool Is_Shorter(const std::string&, const std::string&);
void Elim_Dups(std::vector<std::string> sen)
{
	sort(sen.begin(), sen.end());
	auto the_unique = unique(sen.begin(), sen.end()); //covert the repeat_words to null(or doesnt convert) and move them to the end(after the last element)
	//but the size of the vector isnt changed
	sen.erase(the_unique, sen.end()); //erase the null from the_unique(after the last not null element) to end(before the end)
	stable_sort(sen.begin(), sen.end(), Is_Shorter);
	for (auto& beg : sen)
	{
		std::cout << beg << " " << std::flush;
	}
}
bool Is_Shorter(const std::string& w1, const std::string& w2)
{
	return w1.size() < w2.size();
}
int main()
{
	std::vector<std::string> sentences;
	std::string word = "";
	while (std::cin >> word) //press ctrl+z to stop
	{
		sentences.push_back(word);
	}
	Elim_Dups(sentences);
	//sort(sentences.begin(), sentences.end(), Is_Shorter);
	return 0;
}
```
### ç¯„ä¾‹ç¨‹å¼(Lambda Expression):
```c++
//æ¯”è¼ƒå­—è©é•·çŸ­ä¸¦é‡æ–°æ’åº
void Elim_Dups(std::vector<std::string>);
void Elim_Dups(std::vector<std::string> sen)
{
	sort(sen.begin(), sen.end());
	auto the_unique = unique(sen.begin(), sen.end()); //covert the repeat_words to null and move them to the end(after the last element)
	//but the size of the vector isnt changed
	sen.erase(the_unique, sen.end()); //erase the null from the_unique(after the last not null element) to end(before the end)
	stable_sort(sen.begin(), sen.end(), [](const string& a, const string& b) { return a.size() < b.size(); });
	for (auto& beg : sen)
	{
		std::cout << beg << " " << std::flush;
	}
}
int main()
{
	std::vector<std::string> sentences;
	std::string word = "";
	while (std::cin >> word) //press ctrl+z to stop
	{
		sentences.push_back(word);
	}
	Elim_Dups(sentences);
	//sort(sentences.begin(), sentences.end(), Is_Shorter);
	return 0;
}
```
### è¨»è¨˜:stable_sort:ç¶­æŒç›¸ç­‰å…ƒç´ åŸä¾†çš„é †åºã€‚
### 10. Lambda Expressionçš„æ•æ‰ä¸²åˆ—:
```c++
[sz] (const string& a)
{
	return a.size() >= sz;
}
```
### ç¯„ä¾‹ç¨‹å¼:
```c++
void biggies(std::vector<std::string>& sen, std::ostream& os = std::cout, std::string c = ", ")
{
	for_each(sen.begin(), sen.end(),
		[&os, c](const std::string& s /*æœ¬èº«æ‹¿åˆ°çš„çµæœ*/) { os << s << c; });
}
```
### 11. ä¸€èˆ¬æƒ…æ³ä¸‹ä¸€å€‹Lambdaæ˜¯æ²’è¾¦æ³•æ”¹è®Šå®ƒä»¥å€¼æ•æ‰çš„è®Šæ•¸çš„ï¼Œæˆ‘å€‘éœ€è¦é€šémutableæ‰èƒ½æ”¹è®Šã€‚
```c++
void func3()
{
	size_t v1 = 42;
	auto f = [v1]() mutalbe { return ++v1};
	v1 = 0;
	auto j = f(); //43
}
```
```c++
void func4()
{
	size_t v1 = 42;
	auto f = [&v1]() mutalbe { return ++v1};
	v1 = 0;
	auto j = f(); //1
}
```
### 12. é€šå¸¸ä¾†èªªLambda Expressionæœ€é©åˆåœ¨ä¸éœ€è¦ä½¿ç”¨ä¸€å€‹ä»¥ä¸Šçš„é‹ç®—æ™‚ä½¿ç”¨æœ€å¥½ï¼Œå¦‚æœæ¢ä»¶å¤ªå¤šäº†ï¼Œæœ€å¥½é‚„æ˜¯è¨­è¨ˆä¸€å€‹functionã€‚
## 21 å†æ¢è¿­ä»£å™¨
### 1. é™¤äº†æ¯å€‹å®¹å™¨æ‰€å®šç¾©çš„è¿­ä»£å™¨ä¹‹å¤–ï¼Œæˆ‘å€‘é‚„æœ‰:æ’å…¥è¿­ä»£å™¨(insert iterator)ã€è³‡æ–™æµè¿­ä»£å™¨(stream iterator)ã€åå‘è¿­ä»£å™¨(reverse iterator)ï¼Œä»¥åŠç§»å‹•è¿­ä»£å™¨(move iterator)ã€‚
### æ’å…¥è¿­ä»£å™¨(insert iterator)åˆåˆ†ä¸‰ç¨®:back_inserter(push_back)ã€front_inserter(push_fornt)ï¼Œä»¥åŠinserter(insert)ã€‚
### 2. ç›¸å°çš„æˆ‘å€‘ä¹Ÿå¿…é ˆåœ¨å®¹å™¨æœ‰æ”¯æ´ä»¥ä¸Šå¹¾ç¨®è¿­ä»£å™¨æ™‚ï¼Œæ‰èƒ½ä½¿ç”¨ã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
#include <iostream>
#include <iterator>
#include <list>
int main()
{
	std::list<int> lst = { 1,2,3,4 };
	std::list<int> lst2, lst3; //ç©ºåˆ—è¡¨æ‰€ä»¥lst3.begin() = lst3.end()
	copy(lst.cbegin(), lst.cend(), front_inserter(lst2)); //4 (front) 3 (front) 2 (front) 1 (front)
	for (auto& val : lst2)
	{
		std::cout << val  << " " << std::flush;
	}
	std::cout << std::endl;
	copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.end())); //1 2 3 4 (end)
	for (auto& val : lst3)
	{
		std::cout << val << " " << std::flush;
	}
	return 0;
}
```
### 3. iostreamè¿­ä»£å™¨:
### istream_iterator:è®€å–è¼¸å…¥è³‡æ–™æµã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
int main()
{
	typedef std::istream_iterator<int> int_it;
	int_it it(std::cin);
	int_it it_eof;	
	std::vector<int> vec;
	while (it != it_eof)
	{
		vec.push_back(*it++);
	}
	for (auto& val : vec)
		{
			std::cout << val << " " << std::flush;
		}
	return 0;
}
```
### ostream_iterator:è®€å–è¼¸å…¥è³‡æ–™æµã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
int main()
{
	typedef std::istream_iterator<int> in_it;
	typedef std::ostream_iterator<int> out_it;
	in_it it(std::cin);
	in_it it_eof;
	out_it out(std::cout, " ");
	std::vector<int> vec;
	while (it != it_eof)
	{
		vec.push_back(*it++);
	}
	for (auto& val : vec)
		{
			//*out++ = val;
			out = val; //å¯ä»¥ä¸ç”¨è§£åƒè€ƒè·Ÿéå¢ï¼Œæœƒè‡ªå·±ç§»å‹•
		}
	std::cout << std::flush;
	return 0;
}
```
### ç¯„ä¾‹ç¨‹å¼(æœ€å„ªè§£):
```c++
int main()
{
	typedef std::istream_iterator<int> in_it;
	typedef std::ostream_iterator<int> out_it;
	in_it it(std::cin);
	in_it it_eof;
	out_it out(std::cout, " ");
	std::vector<int> vec;	
	while (it != it_eof)
	{
		vec.push_back(*it++);
	}
	copy(vec.begin(), vec.end(), out);
	std::cout << std::flush;
	return 0;
}
```
### 4. åå‘è¿­ä»£å™¨æ˜¯ä¸€å€‹å¾€å›å·¡è¨ªçš„è¿­ä»£å™¨ï¼Œå¾æœ€å¾Œä¸€å€‹å…ƒç´ é–‹å§‹æœå‘ç¬¬ä¸€å€‹å…ƒç´ ã€‚
### 5. è¦æ³¨æ„ï¼Œå®ƒåè½‰äº†éå¢(++)èˆ‡éæ¸›(--)çš„æ„ç¾©:"++"è®Šæˆå‘å‰ï¼Œ"--"è®Šæˆå‘å¾Œã€‚
### 6. é™¤äº†forward_listä¹‹å¤–ï¼Œæ‰€æœ‰çš„å®¹å™¨éƒ½æœ‰åå‘è¿­ä»£å™¨ã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
//reverse iterator
int main()
{
	std::vector<int> vec = { 0,1,2,3,4,5,6,7,8,9 };
	for (auto r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter) //crbeginæ˜¯vec[9],crendæ˜¯vec[0]çš„å‰ä¸€å€‹ç©ºä½ç½®
	{
		std::cout << *r_iter << " " << std::flush;
	}
	return 0;
}
```
## ç·´ç¿’é¡Œ21
```c++
// è¨­è¨ˆä¸€å€‹å¯ä»¥æ‰¾å‡ºæ¨™é»ç¬¦è™Ÿçš„ç¨‹å¼
// å¯ä»¥é¸æ“‡å°å‡ºé€—è™Ÿå‰å¾Œçš„å–®å­—/å¥å­
// å¥å­ç”±ä½¿ç”¨è€…è‡ªå·±è¼¸å…¥
// ä¸¦ä¸”å¯ä»¥æ±ºå®šè¦å°‹æ‰¾å“ªä¸€å€‹æ¨™é»ç¬¦è™Ÿ
int main()
{
	typedef std::ostream_iterator<std::string> out_it;
	std::string words, decide;
	char symbols;
	getline(std::cin, words);
	auto find_comma = find(words.cbegin(), words.cend(), ','); //åªèƒ½æ‰¾string
	auto rfind_comma = find(words.crbegin(), words.crend(), ','); //åªèƒ½æ‰¾string
	auto find_question_mark = find(words.cbegin(), words.cend(), '?'); //åªèƒ½æ‰¾string
	auto rfind_question_mark = find(words.crbegin(), words.crend(), '?'); //åªèƒ½æ‰¾string
	auto find_period = find(words.cbegin(), words.cend(), '.'); //åªèƒ½æ‰¾string
	auto rfind_period = find(words.crbegin(), words.crend(), '.'); //åªèƒ½æ‰¾string
	bool foundornot = false;
	int decision = 0;
	std::cout << "Please decide which symbols you want to find?(comma, period or question mark)" << std::endl;
	std::cin >> symbols;
	if (symbols == ',')
	{
		if (find_comma != words.end())
		{
			foundornot = true;
			decision = 1;
		}
		else
		{
			std::cerr << "There is no comma." << std::endl;
			return -1;
		}
	}
	else if (symbols == '.')
	{
		if (find_period != words.end())
		{
			foundornot = true;
			decision = 2;
		}
		else
		{
			std::cerr << "There is no period." << std::endl;
			return -1;
		}
	}
	else if (symbols == '?')
	{
		if (find_question_mark != words.end())
		{
			foundornot = true;
			decision = 3;
		}
		else
		{
			std::cerr << "There is no question mark." << std::endl;
			return -1;
		}
	}
	switch (decision)
	{
	case 1: //comma
		std::cout << "Please decide to find which words, the first one or the last one?(first or last)" << std::endl;
		std::cin >> decide;
		if (decide == "first")
		{
			std::cout << std::string(words.cbegin(), find_comma) << std::flush;
		}
		else if (decide == "last")
		{
			std::cout << std::string(rfind_comma.base(), words.cend()) << std::flush;
		}
		else
		{
			std::cerr << "Invalid Input" << std::endl;
			return -1;
		}
		break;
	case 2: //period
		std::cout << "Please decide to find which words, the first one or the last one?(first or last)" << std::endl;
		std::cin >> decide;
		if (decide == "first")
		{
			std::cout << std::string(words.cbegin(), find_period) << std::flush;
		}
		else if (decide == "last")
		{
			std::cout << std::string(rfind_period.base(), words.cend()) << std::flush;
		}
		else
		{
			std::cerr << "Invalid Input" << std::endl;
			return -1;
		}
		break;
	case 3: //question mark
		std::cout << "Please decide to find which words, the first one or the last one?(first or last)" << std::endl;
		std::cin >> decide;
		if (decide == "first")
		{
			std::cout << std::string(words.cbegin(), find_question_mark) << std::flush;
		}
		else if (decide == "last")
		{
			std::cout << std::string(rfind_question_mark.base(), words.cend()) << std::flush;
		}
		else
		{
			std::cerr << "Invalid Input" << std::endl;
			return -1;
		}
	}
	return 0;
}
```
### 7. è¿­ä»£å™¨çš„åˆ†é¡:
### è¼¸å…¥è¿­ä»£å™¨(input iterator):è®€å–ä½†ä¸å¯«å…¥ï¼Œå–®å›ï¼Œåƒ…éå¢ã€‚
### è¼¸å‡ºè¿­ä»£å™¨(output iterator):å¯«å…¥ä½†ä¸è®€å–ï¼Œå–®å›ï¼Œåƒ…éå¢ã€‚
### æ­£å‘è¿­ä»£å™¨(forward iterator):è®€å–ä¸”å¯«å…¥ï¼Œå¤šå›ï¼Œåƒ…éå¢ã€‚
### é›™å‘è¿­ä»£å™¨(bidirectional iterator):è®€å–ä¸”å¯«å…¥ï¼Œå¤šå›ï¼Œéå¢åŠéæ¸›ã€‚
### éš¨æ©Ÿå­˜å–è¿­ä»£å™¨(random-access iterator):è®€å–ä¸”å¯«å…¥ï¼Œå¤šå›ï¼Œå®Œæ•´çš„è¿­ä»£å™¨é‹ç®—è¡“ã€‚


## 22 é—œè¯å¼å®¹å™¨
### 1. èˆ‡å¾ªåºæ€§å®¹å™¨ä¸åŒï¼Œå¾ªåºæ€§å®¹å™¨å¼é€šéä½ç½®ä¾†åšå­˜å–ï¼Œä½†æ˜¯é—œè¯æ€§å®¹å™¨æ˜¯é€šééµ(key)ä¾†åšå­˜å–çš„ã€‚
### 2. é—œè¯å¼å®¹å™¨ä¸»è¦åˆ†å…©å€‹å‹åˆ¥:mapè·Ÿsetã€‚
### 3. map:å…¶ä¸­åŒ…å«çš„å…ƒç´ æœ‰éµ(key)è·Ÿå€¼å°çµ„(key-value pairs)
### å…¶ä¸­keyæ˜¯ç´¢å¼•ï¼Œè€Œå€¼å‰‡æ˜¯é‚£å€‹ç´¢å¼•æ‰€é—œè¯çš„è³‡æ–™ã€‚å­—å…¸æœƒæ˜¯å¾ˆå¥½çš„ä¾‹å­ï¼Œå–®å­—æ˜¯keyï¼Œè§£é‡‹æ˜¯å€¼ã€‚
### 4. set:å…¶ä¸­åªå«æœ‰ä¸€å€‹éµ(key)ï¼Œkeyå°±æ˜¯valueã€‚
### setæ”¯æ´æœ‰æ•ˆç‡çš„æŸ¥è©¢ä¸€å€‹keyæ˜¯å¦å­˜åœ¨ã€‚
### 5. mapé€šå¸¸æœƒè¢«ç¨±ä½œé—œè¯æ€§é™£åˆ—ï¼Œåªæ˜¯ä»–çš„ä¸‹æ¨™(index)ä¸¦ä¸ä¸€å®šè¦æ˜¯æ•´æ•¸è€Œå·²ã€‚å†ä¾†ï¼Œå¦‚æœæˆ‘å€‘è¦å°‹æ‰¾mapè£¡é¢çš„å€¼ï¼Œä¹Ÿä¸¦éæ˜¯é€šéä½ç½®ï¼Œè€Œæ˜¯keyã€‚
### 6. ç›¸æ¯”æ–¼mapï¼Œsetå°±åªæ˜¯ä¸€äº›ç”±keyæ‰€çµ„æˆçš„ç¾¤é›†ã€‚å°±æ¯”å¦‚è£½ä½œé»‘åå–®äººå“¡ï¼Œæˆ‘å€‘å°±å¯ä»¥ä½¿ç”¨ä¸€å€‹setä¾†å­˜å–é€™äº›äººå“¡ï¼Œä¹‹å¾Œåªè¦é€šékeyå°±å¯ä»¥æŸ¥æ‰¾é‚£å€‹ä»æ˜¯å¦æœ‰åœ¨é»‘åå–®è£¡é¢äº†ã€‚
### ç¯„ä¾‹ç¨‹å¼(map):
```c++
#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <map>
int main()
{
	std::map<std::string, size_t> word_count; //std::map<key(index),the type of value> map_name
	std::string word;
	while (std::cin >> word) //use word to be a (key)index and store it(each time plus one)
	{
		++word_count[word];
	}
	for (const auto& c : word_count) //print the data of the map(first for key(index) and second for the value)
	{
		std::cout << c.first << ": " << c.second << ((c.second > 1) ? " times" : " time") << std::endl;
	}
	return 0;
}
```
## ç·´ç¿’é¡Œ22
```c++
#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <map>
#include <set>
#include <algorithm>
//map and set è¨­è¨ˆä¸€å€‹å¿½ç•¥å¤§å°å¯«èˆ‡æ¨™é»ç¬¦è™Ÿçš„è¨˜æ•¸ç¨‹å¼ e.g exampleè·Ÿexample.éƒ½æœƒå¢åŠ 
int main()
{
	std::map<std::string, size_t> word_count; //std::map<key(index),the type of value> map_name
	std::set<char> exclude = { ',', '.', '?', ':', '!' };
	std::string word;
	std::cout << "Please enter the words:" << std::endl;
	while (std::cin >> word) //use word to be a (key)index and store it(each time plus one)
	{
		std::transform(word.begin(), word.end(), word.begin(), ::tolower); //convert the string to lowercase and copy into word(from begin) again
		for (const auto& m : exclude) //å¾setä¸­å–æ¨™é»ç¬¦è™Ÿ
		{
			auto mark = find(word.begin(), word.end(), m); //æ‰¾é‚Šæ¨™é»ç¬¦è™Ÿ
			if (mark != word.end()); //æ‰¾åˆ°äº†
			{
				word = std::string(word.begin(), mark); //å¿½ç•¥æ¨™é»ç¬¦è™Ÿ
			}		
		}
		++word_count[word];
	}
	for (const auto& c : word_count) //print the data of the map(first for key(index) and second for the value)
	{
		std::cout << c.first << ": " << c.second << ((c.second > 1) ? " times" : " time") << std::endl;
	}
	return 0;
}
```
### 7. é—œè¯å¼å®¹å™¨ä¸¦ä¸æ”¯æ´å¾ªåºå®¹å™¨ä¸Šé‚£äº›åŸºæ–¼ä½ç½®çš„é‹ç®—ã€‚
### 8. é—œè¯å¼å®¹å™¨çš„è¿­ä»£æ˜¯é›™å‘çš„ã€‚
### 9. æ¯å€‹mapè·Ÿsetçš„éµéƒ½æ˜¯å”¯ä¸€çš„ï¼Œä½†æ˜¯multiampè·Ÿmultisetå°±æ²’æœ‰é€™ç¨®é™åˆ¶ã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
//multimap and multiset 
int main()
{
	std::vector<unsigned> vec;
	for (unsigned i = 0; i != 10; ++i)
	{
		vec.push_back(i);
		vec.push_back(i);
	}
	std::set<unsigned> iset(vec.cbegin(), vec.cend());
	std::multiset<unsigned> multiset(vec.cbegin(), vec.cend());
	std::cout << vec.size() << std::endl;
	std::cout << iset.size() << std::endl;
	std::cout << multiset.size() << std::endl;
	for (const auto& val : vec)
	{
		std::cout << val << " " << std::flush;
	}
	std::cout << std::endl;
	for (const auto& val : iset)
	{
		std::cout << val << " " << std::flush;
	}
	std::cout << std::endl;
	for (const auto& val : multiset)
	{
		std::cout << val << " " << std::flush;
	}
	return 0;
}
```
### 10. pairå‹åˆ¥:ä¸€å€‹pairå­˜æœ‰å…©å€‹è³‡æ–™æˆå“¡ï¼Œæ˜¯ä¸€å€‹æ¨¡æ¿ï¼Œè®“æˆ‘å€‘ç”¢å‡ºç‰¹åˆ¥çš„å‹åˆ¥ã€‚
### 11. pairå­˜æ”¾æ–¼utlityçš„æ¨™é ­æª”ä¸­ã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
int main()
{
	std::pair<std::string, std::string> author;
	return 0;
}
```
### 12. å°æ–¼setä¾†èªªï¼Œæ¯å€‹keyå°±æ˜¯valueã€‚ä½†æ˜¯å¦‚æœæˆ‘å€‘æ¢è¨çš„æ˜¯mapï¼Œå°±æ˜¯ä¸ä¸€æ¨£äº†ã€‚
### mapæ˜¯ç”±key-valueæ‰€çµ„æˆçš„ï¼Œé€™ä»£è¡¨æ¯ä¸€å€‹å…ƒç´ éƒ½æ˜¯pairã€‚åŒæ™‚ï¼Œæˆ‘å€‘ä¹Ÿè¦è¨˜å¾—ï¼Œkeyæ˜¯constçš„ï¼Œä¸å¯æ”¹è®Šï¼Œä½†æ˜¯valueå¯ä»¥æ”¹è®Šã€‚
### 13. setçš„keyæ˜¯constçš„ï¼Œé€™ä»£è¡¨setçš„è¿­ä»£å™¨ä¹Ÿæ˜¯constçš„ã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
int main()
{	
	std::set<int> iset = { 0,1,2,3,4,5,6,7,8,9 };
	auto isetb = iset.begin();
	while (isetb != iset.end())
	{
		std::cout << *isetb++ << " " << std::flush;
	}
	return 0;
}
```
### 14. æ–°å¢å…ƒç´ :
### ç¯„ä¾‹ç¨‹å¼:
```c++
//æ–°å¢å…ƒç´ åˆ°set
int main()
{
	std::vector<int> vec = { 2,4,6,8,2,4,6,8 };
	std::set<int> iset, iset2;
	iset.insert(vec.begin(),vec.end()); //å”¯ä¸€æ€§ï¼Œæ‰€ä»¥é‡è¤‡çš„ä¸æœƒå†æ”¾é€²å»
	auto isetb = iset.begin();
	while (isetb != iset.end())
	{
		std::cout << *isetb++ << " " << std::flush;
	}
	std::cout << std::endl;
	iset.insert({ 1,3,5,7,1,3,5,7 });
	isetb = iset.begin();
	while (isetb != iset.end())
	{
		std::cout << *isetb++ << " " << std::flush;
	}
	return 0;
}
```
### ç¯„ä¾‹ç¨‹å¼:
```c++
//æ–°å¢å…ƒç´ åˆ°map
int main()
{
	std::map<std::string, unsigned> word_count;
	std::string word;
	while (std::cin >> word)
	{
		word_count.insert({ word, 1 }); //return pair(map,true or flae) mapåˆåˆ†æˆmap->first(key) map-->second(value)
	}
	auto beg = word_count.begin();
	while (beg != word_count.end()) //iterator use -> to get the value
	{
		std::cout << beg->first << " " << beg->second << std::endl;
		++beg;
	}
	return 0;
}
```
### 15. ç§»é™¤å…ƒç´ :
### ç¯„ä¾‹ç¨‹å¼:
```c++
int main()
{
	std::map<std::string, unsigned> word_count;
	std::string word;
	int ctr = 0;
	while (ctr < 4 && std::cin >> word)
	{
		word_count.insert({ word, 1 });
		++ctr;
	}
	auto beg = word_count.begin();
	while (beg != word_count.end()) //iterator use -> to get the value
	{
		std::cout << beg->first << " " << beg->second << std::endl;
		++beg;
	}
	std::cout << "Please enter what word you want to remove: " << std::flush;
	std::string removed;
	std::cin >> removed;
	if (word_count.erase(removed))
	{
		beg = word_count.begin();
		while (beg != word_count.end()) //iterator use -> to get the value
		{
			std::cout << beg->first << " " << beg->second << std::endl;
			++beg;
		}
	}
	else
	{
		std::cout << removed << "is not found." << std::endl;
	}
	return 0;
}
```
### 16. æ·»æ¨™:æˆ‘å€‘å¯ä»¥å¹«mapè·Ÿunordered_mapæä¾›ä¸‹æ¨™ã€‚
### ä½†æ˜¯æ²’è¾¦æ³•å°setæ·»æ¨™ï¼Œå› ç‚ºsetçš„keyå°±æ˜¯valueæ²’æœ‰æˆå°ã€‚ç„¶å¾Œmultimapä¹Ÿä¸è¡Œï¼Œå› ç‚ºåŒä¸€å€‹keyå¯èƒ½æœ‰å¤šå€‹å€¼;ç°¡å–®é»ä¾†è¬›ï¼Œå°±æ˜¯ä¸€å€‹ä¸‹æ¨™æœƒæœ‰å¤šå€‹å€¼ã€‚
### 17. å­˜å–å…ƒç´ :å¦‚æœæˆ‘å€‘åªæ˜¯æƒ³è¦å°‹æ‰¾æŸä¸€å€‹å…ƒç´ æœ‰æ²’æœ‰åœ¨å®¹å™¨ä¸­ï¼Œé‚£ä½¿ç”¨find()æœƒæ˜¯å€‹å¥½æ–¹æ³•ã€‚
### ä½†é€™æ˜¯åœ¨key-valueå…·æœ‰å”¯ä¸€æ€§æ™‚æ‰æ˜¯å¦‚æ­¤ã€‚å¦‚æœæ˜¯æœ‰å¤šé‡éµå€¼çš„å®¹å™¨ï¼Œé‚£éº¼ä½¿ç”¨countæœƒå¥½ä¸€äº›ã€‚
### findæœƒå›å‚³è¿­ä»£å™¨ï¼Œè€Œcountå‰‡æœƒå›å‚³é‚£å€‹å…ƒç´ å‡ºç¾äº†å¹¾æ¬¡ã€‚
### 18. å› ç‚ºfindæ˜¯å›å‚³è¿­ä»£å™¨ï¼Œæ‰€ä»¥æˆ‘å€‘å¯ä»¥é€šéè¿­ä»£å™¨çš„æ–¹å¼ï¼Œä¾†åˆ¤æ–·è©²å…ƒç´ æ˜¯å¦å­˜åœ¨:
```c++
if(word.count.find("foot") == word.count.end()) //è¡¨ç¤ºä¸å­˜åœ¨
	std::cout << "not found" << std::endl;
```
### è¨»è¨˜:ä½¿ç”¨ä¸‹æ¨™ä¾†å°‹æ‰¾å…ƒç´ æ™‚ï¼Œå¦‚æœè©²å…ƒç´ ä¸å­˜åœ¨ï¼Œé‚£éº¼é›»è…¦æœƒè‡ªå‹•å¹«æˆ‘å€‘æ–°å¢ï¼Œé€™ä¹Ÿæ˜¯æˆ‘å€‘ä½¿ç”¨è¿­ä»£å™¨ä¾†å°‹æ‰¾å…ƒç´ çš„ä¸»è¦åŸå› ã€‚
### 19. ç•¶ä¸€å€‹multimapæˆ–multisetæœ‰å¤šå€‹å…ƒç´ å…·æœ‰ç›¸åŒçš„éµå€¼æ™‚ï¼Œé€™äº›å…ƒç´ æœƒå½¼æ­¤ç›¸é„°ã€‚
### ç¯„ä¾‹ç¨‹å¼:
```c++
//å°‹æ‰¾ç‰¹å®šå…ƒç´ 
int main()
{
	std::multimap<std::string, double> fruits;
	std::string fruit;
	double price;
	unsigned ctr = 0;
	std::cout << "The fruit: " << std::flush;
	while (ctr < 5 && std::cin >> fruit)
	{
		std::cout << "The price: " << std::flush;
		std::cin >> price;
		fruits.insert({ fruit ,price });
		++ctr;
		if (ctr != 5)
			std::cout << "The fruit: " << std::flush;
	}
	std::string search;
	std::cout << "Please enter what fruit you want to find: " << std::flush;
	std::cin >> search;
	auto total = fruits.count(search);
	auto beg = fruits.begin();
	while (total)
	{
		std::cout << beg->first << " " << beg->second << std::endl;
		++beg;
		--total;
	}
	return 0;
}
```
### ç¯„ä¾‹ç¨‹å¼(å„ªåŒ–):
```c++
int main()
{
	std::multimap<std::string, double> fruits;
	std::string fruit;
	double price;
	unsigned ctr = 0;
	std::cout << "The fruit: " << std::flush;
	while (ctr < 5 && std::cin >> fruit)
	{
		std::cout << "The price: " << std::flush;
		std::cin >> price;
		fruits.insert({ fruit ,price });
		++ctr;
		if (ctr != 5)
			std::cout << "The fruit: " << std::flush;
	}
	std::string search;
	std::cout << "Please enter what fruit you want to find: " << std::flush;
	std::cin >> search;
	for (auto beg = fruits.lower_bound(search), end = fruits.upper_bound(search); beg != end; ++beg)
	{
		std::cout << beg->first << " " << beg->second << std::endl;
	}
	return 0;
}
```
### ç¯„ä¾‹ç¨‹å¼(æœ€ä½³åŒ–):
```c++
int main()
{
	std::multimap<std::string, double> fruits;
	std::string fruit;
	double price;
	unsigned ctr = 0;
	std::cout << "The fruit: " << std::flush;
	while (ctr < 5 && std::cin >> fruit)
	{
		std::cout << "The price: " << std::flush;
		std::cin >> price;
		fruits.insert({ fruit ,price });
		++ctr;
		if (ctr != 5)
			std::cout << "The fruit: " << std::flush;
	}
	std::string search;
	std::cout << "Please enter what fruit you want to find: " << std::flush;
	std::cin >> search;
	for (auto pos = fruits.equal_range(search); pos.first != pos.second; ++pos.first)
	{
		std::cout << pos.first->first << " " << pos.first->second << std::endl;
	}
	return 0;
}
```
### 20. å¦‚ä¸Šé¢çš„ç¯„ä¾‹ç¨‹å¼ï¼Œæˆ‘å€‘ä¹Ÿå¯ä»¥é€šélower_boundèˆ‡upper_boundä¾†é€²è¡Œé™å®šæŸ¥è©¢ï¼Œç•¶å…©è€…å›å‚³ç›¸åŒçš„è¿­ä»£å™¨æ™‚ï¼Œå³ä»£è¡¨æ‰€çµ¦çš„å€¼å·²ä¸å†å®¹å™¨å…§éƒ¨äº†ã€‚
## ç¶œåˆç·´ç¿’:
```c++
// è¨­è¨ˆä¸€å€‹å­—è©è½‰æ›ç¨‹å¼
// ä½¿ç”¨è€…å¯ä»¥è‡ªå·±æ±ºå®šè¦æ”¹è®Šæˆç”šéº¼å–®å­—
// å¥å­ä½¿ç”¨è€…è‡ªå·±è¼¸å…¥
/*
* 1.read word function
* 2.transform function
*/
void read_word(const std::map<std::string, std::string>&, std::ifstream&);
const std::string& transform(const std::string&, const std::map<std::string, std::string>&);
const std::string& transform(const std::string& s, const std::map<std::string,std::string>& m)
{
	auto map_it = m.find(s); //å¾å®¹å™¨ä¸­å°‹æ‰¾sï¼Œä¹Ÿå°±æ˜¯æˆ‘å€‘è¼¸å…¥å¥å­è£¡é¢çš„å„å€‹å–®å­—

	if (map_it != m.end()) //å¦‚æœæœ‰æ‰¾åˆ°
		return map_it->second; //æŠŠé‚£å€‹å­—æ›¿æ›ç‚ºå®¹å™¨ä¸­çš„second å¦‚rè¦è®Šæˆare

	else
		return s;
}
void read_word(const std::map<std::string, std::string>& m)
{
	std::string text;
	std::cout << "Please enter the sentence: " << std::endl;
	while (getline(std::cin, text)) //é–‹å§‹è¼¸å…¥å¥å­
	{
		std::istringstream stream(text); //å°‡æ¯å€‹å–®å­—åˆ†é–‹æ‹¿å‡ºä¾†é€™æ˜¯ä¸€å€‹"æµ"
		std::string word; //ç”¨ä¾†å­˜æ”¾æµè£¡é¢çš„å–®å­—
		bool firstword = true; //ç”¨ä¾†åˆ¤æ–·æ˜¯ä¸æ˜¯ç¬¬ä¸€å€‹å­—
		while(stream >> word) //é–‹å§‹æŠŠæµè£¡é¢çš„å­—ä¸€å€‹ä¸€å€‹æ”¾é€²å»
		{
			if (firstword)
				firstword = false;
			else
				std::cout << " " << std::flush; //å¦‚æœæ˜¯å¾Œé¢çš„å–®å­—ï¼Œå°å‡ºä¾†ä¹‹å‰è¦åŠ ç©ºæ ¼
			std::cout << transform(word, m); //å°å‡ºè®ŠåŒ–å¾Œçš„çµæœ
		}
	}	
}
int main()
{
	std::cout << "This program is designed to change the word, you can enter 5 rules totally." << std::endl;
	std::map<std::string, std::string> changed_map; //å®£å‘Šå®¹å™¨
	std::string bechanged, change;
	int ctr = 0;
	while(ctr < 5)
	{
		std::cout << "Please enter the word you want to change: " << std::flush;
		std::cin >> bechanged;
		std::cout << "Please enter what word you want to change to: " << std::flush;
		std::cin >> change;
		changed_map.insert({ bechanged, change }); //æŠŠè¦æ›´æ”¹çš„å€¼å­˜å…¥å®¹å™¨å…§
		++ctr;
		std::cin.get(); //é‡‹æ”¾cinç·©è¡å€
	}
	read_word(changed_map);
	return 0;
}
```
### 21. ç„¡åºé—œè¯å¼å®¹å™¨:ä¸ä½¿ç”¨ä¸€èˆ¬æ¯”è¼ƒé‹ç®—å­ä¾†çµ„ç¹”å…ƒç´ ï¼Œè€Œæ˜¯ä½¿ç”¨hash_functionï¼Œä»¥åŠéµå€¼å‹åˆ¥çš„"=="ã€‚
### 22. ç„¡åºå®¹å™¨æœƒè¢«çµ„ç¹”æˆç”±bucketæ‰€çµ„æˆçš„ä¸€å€‹ç¾¤é›†(a collection of buckets)ã€‚
### 23. ç„¡åºå®¹å™¨çš„æ•ˆèƒ½å–æ±ºæ–¼hash functionä»¥åŠbucketsçš„æ•¸é‡è·Ÿå¤§å°ã€‚

## 23 å‹•æ…‹è¨˜æ†¶é«”(Dynamic Memory)
### 1. éœæ…‹è¨˜æ†¶é«”:å­˜æ”¾å€åŸŸèˆ‡é¡åˆ¥çš„staticç‰©ä»¶æˆ–æˆå“¡ï¼Œä»¥åŠä»»ä½•å‡½å¼å®šç¾©å¤–çš„è®Šæ•¸ã€‚
### 2. éœæ…‹è¨˜æ†¶é«”:å­˜æ”¾å‡½å¼å…§çš„éstaticç‰©ä»¶ã€‚
### 3. éœæ…‹è¨˜æ†¶é«”èˆ‡éœæ…‹è¨˜æ†¶é«”:å®ƒå€‘æ‰€é…ç½®çš„ç‰©ä»¶éƒ½æœƒç”±ç·¨è­¯å™¨è‡ªå‹•å‰µå»ºè·Ÿæ‘§æ¯€ã€‚
### 4. å‹•æ…‹è¨˜æ†¶é«”çš„ç®¡ç†å¼é€šé:newèˆ‡deleteä¾†é€²è¡Œçš„ã€‚
### 5. shared_ptr:å…è¨±å¤šå€‹æŒ‡æ¨™æŒ‡å‘åŒä¸€å€‹ç‰©ä»¶ï¼Œå­˜æ”¾æ–¼æ¨™æº–å‡½å¼åº«è£¡ã€‚
### 5. unique_ptr:è¡¨ç¤ºé€™å€‹æŒ‡æ¨™æ“æœ‰å®ƒæ‰€æŒ‡çš„ç‰©ä»¶ã€‚
### 6. weak_ptr:å¼±åƒè€ƒ(weak reference)æŒ‡å‘ç”±ä¸€å€‹shared_ptrç®¡ç†çš„ç‰©ä»¶ã€‚
### 7. è·Ÿvectorä¸€æ¨£ï¼Œæ™ºæ…§æŒ‡æ¨™ä¹Ÿæ˜¯æ¨¡æ¿ï¼Œå®£å‘Šæ–¹å¼å¦‚ä¸‹:
```c++
int main()
{
	std::shared_ptr<int> p1 = std::make_shared<int>(42); //p is a shared ptr point to an int and the value of the int is 42
	std::shared_ptr<std::string> p2 = std::make_shared<std::string>(10,'9'); //p is a shared ptr point to a string and the value of the string is "9999999999"
	std::shared_ptr<int> p3 = std::make_shared<int>(); //p is a shared ptr point to an int and the value is initialized to 0
	std::cout << *p1 << " " << *p2 << " " << *p3 << std::endl;
	return 0;
}
```
### ç•¶ç„¶ï¼Œä¸€èˆ¬ä¾†èªªæˆ‘å€‘å¯ä»¥ç›´æ¥ä½¿ç”¨autoä¾†å®£å‘Š:
```c++
int main()
{
	auto p1 = std::make_shared<int>(42); //p is a shared ptr point to an int and the value of the int is 42
	auto p2 = std::make_shared<std::string>(10,'9'); //p is a shared ptr point to a string and the value of the string is "9999999999"
	auto p3 = std::make_shared<int>(); //p is a shared ptr point to an int and the value is initialized to 0
	std::cout << *p1 << " " << *p2 << " " << *p3 << std::endl;
	return 0;
}
```
### 8. ç•¶æˆ‘å€‘åœ¨æ‹·è²æˆ–è€…æŒ‡å®šä¸€å€‹shared_ptræ™‚ï¼Œå®ƒå…§éƒ¨éƒ½æœƒæœ‰ä¸€å€‹è¨ˆæ•¸å™¨ï¼Œç”¨ä¾†è¨˜éŒ„ç•¶å‰ç¸½å…±æœ‰å¹¾å€‹shared_ptræŒ‡å‘ç›¸åŒçš„ç‰©ä»¶ã€‚
### æ›å¥è©±èªªï¼Œåªè¦shared_ptrçš„è¨ˆæ•¸å™¨ç‚ºé›¶ï¼Œé‚£å°±ä»£è¡¨è‘—è©²ç‰©ä»¶è¦è¢«è‡ªå‹•é‡‹æ”¾äº†ã€‚
### 9. å¦‚ä¸Šè¿°ï¼Œshared_ptræœƒè‡ªå‹•é‡‹æ”¾é—œè¯çš„è¨˜æ†¶é«”ã€‚
### 10. æˆ‘å€‘ä¹‹æ‰€ä»¥è¦ä½¿ç”¨å‹•æ…‹è¨˜æ†¶é«”ï¼Œæ˜¯ç‚ºäº†è®“å¤šå€‹ç‰©ä»¶å…±ç”¨ç›¸åŒçš„ç‹€æ…‹ã€‚
### ç¯„ä¾‹ç¨‹å¼:å®šç¾©ä¸€å€‹æ¨¡æ¿
```c++
#include <iostream>
#include <vector>
#include <string>
#include <memory>
class StrBlob
{
public:
	typedef std::vector<std::string>::size_type size_type; //typedefine
	StrBlob() : data(std::make_shared<std::vector<std::string>>()) {}; //constructor
	StrBlob(std::initializer_list<std::string> il) : data(std::make_shared<std::vector<std::string>>()) {}; //constructor
	size_type size() const { return data->size(); } //function get_size
	bool empty() const { return data->empty(); } //function check empty
	void push_back(const std::string& s) { data->push_back(s); } //insert element to back
	void pop_back(); // erase element from back
	std::string& front(); //get the frist element
	const std::string& front() const;
	std::string& back(); //get the last element
	const std::string& back() const;
private:
	std::shared_ptr<std::vector<std::string>> data; //a shared_ptr
	inline void check(size_type i, const std::string& msg) const;
};
int main()
{
	StrBlob data1;
	data1.push_back("10");
	data1.push_back("20");
	data1.push_back("30");
	std::cout << data1.front() << std::endl;
	std::cout << data1.back() << std::endl;
	data1.pop_back();
	std::cout << data1.back() << std::endl;
	return 0;
}
void StrBlob::check(size_type i, const std::string& msg) const
{
	if (i >= data->size())
		throw std::out_of_range(msg);
}
void StrBlob::pop_back()
{
	check(0, "pop_back on empty StrBlob.");
	data->pop_back();
}
std::string& StrBlob::front()
{
	check(0, "front on empty StrBlob.");
	return data->front();
}
const std::string& StrBlob::front() const
{
	check(0, "front on empty StrBlob.");
	return data->front();
}
std::string& StrBlob::back()
{
	check(0, "back on empty StrBlob.");
	return data->back();
}
const std::string& StrBlob::back() const
{
	check(0, "back on empty StrBlob.");
	return data->back();
}
```
### 11. newæœƒå›å‚³ä¸€å€‹"æŒ‡æ¨™"æŒ‡å‘å®ƒæ‰€é…ç½®çš„ç‰©ä»¶ã€‚
```c++
int* pi = new int; //piæŒ‡å‘ä¸€å€‹å‹•æ…‹é…ç½®ï¼Œä¸”ç„¡åæœªåˆå§‹åŒ–çš„int
```
### 12. å¦‚åŒæˆ‘å€‘æœƒåˆå§‹åŒ–è®Šæ•¸ä¸€æ¨£ï¼Œåˆå§‹åŒ–å‹•æ…‹é…ç½®çš„ç‰©ä»¶ä¹Ÿæ˜¯å€‹å¥½ç¿’æ…£ã€‚
### 13. newä¹Ÿå¯ä»¥é…ç½®cosntç‰©ä»¶ã€‚
### 14. æˆ‘å€‘å¯ä»¥ç”¨ä»¥ä¸‹æ–¹æ³•ä¾†è§£æ±ºè®“newé…ç½®å¤±æ•—æ™‚å›å‚³ä¸€å€‹nullprtã€‚
```c++
int* pi = new(nothrow) int; //å›å‚³ä¸€å€‹nullprt
```
### 15. ç‚ºäº†é¿å…å‹•æ…‹è¨˜æ†¶é«”è€—ç›¡ï¼Œæˆ‘å€‘å¿…é ˆåœ¨ä½¿ç”¨å®Œå¾Œï¼Œé€šédeleteçš„æ–¹å¼ä¾†å°‡è¨˜æ†¶é«”æ­¸é‚„çµ¦ç³»çµ±ã€‚
```c++
delete p; //på¿…é ˆæ˜¯ä¸€å€‹å‹•æ…‹é…ç½®çš„ç‰©ä»¶æˆ–è€…æ˜¯null
int i, * pi1 = &i, * pi2 = nullptr;
double* pd = new double(33), * pd2 = pd;
delete i; //error its an int
delete pi1;//undefined it points to a value
delete pd; //ok point to a dynamic object
delete pd2;//undefined the object already be deleted 
delete pi2; //ok a nullptr
```
### 16. åœ¨delete pi1ç·¨è­¯å™¨ä¸æœƒé¦¬ä¸Šå ±éŒ¯ï¼Œé€™æ˜¯ä¸€å€‹æ½›åœ¨çš„éŒ¯èª¤ï¼Œå› ç‚ºç·¨è­¯å™¨ç„¡æ³•åˆ¤æ–·é€™å€‹æŒ‡æ¨™æ˜¯å¦ç‚ºå‹•æ…‹çš„ã€‚
### åŒæ¨£çš„ï¼Œåœ¨delete pd2ç·¨è­¯å™¨ä¹Ÿä¸æœƒé¦¬ä¸Šå ±éŒ¯ï¼Œå› ç‚ºå®ƒç„¡æ³•åˆ¤æ–·é‚£å€‹ä½ç½®çš„è¨˜æ†¶é«”æ˜¯å¦è¢«é‡‹æ”¾äº†ã€‚
### 17. ç•¶æˆ‘å€‘çš„å‡½å¼å›å‚³ä¸€å€‹å‹•æ…‹ç‰©ä»¶(å‹•æ…‹æŒ‡æ¨™æ‰€æŒ‡çš„ç‰©ä»¶)ï¼Œé‚£éº¼å¾Œé¢ä½¿ç”¨åˆ°é€™å€‹å‡½å¼çš„å‘¼å«è€…ï¼Œå°±è¦è² è²¬é‡‹æ”¾å‹•æ…‹è¨˜æ†¶é«”ã€‚
```c++
int* factory(int val)
{
	return new int(val);
}
void use_factory(int val)
{
	int* p = factory(val); //p need to be deleted
	delete p;
}
```
### 18. é›–ç„¶æˆ‘å€‘deleteä¸€å€‹æŒ‡æ¨™å¾Œï¼Œå°±ä»£è¡¨è‘—é‚£å€‹æŒ‡æ¨™ç„¡æ•ˆäº†ï¼Œä½†åœ¨è¨±å¤šæ©Ÿå™¨ä¸Šï¼Œé€™äº›è¢«deleteçš„æŒ‡æ¨™æœƒè¢«è®Šæˆdangling pointer(æ‡¸ç½®æŒ‡æ¨™)ã€‚
### æ‰€è¬‚dangling pointeræ‰€æŒ‡å‘çš„æ­£æ˜¯æ›¾ç¶“æŒ‡å‘æŸå€‹ç‰©ä»¶çš„è¨˜æ†¶é«”ï¼Œä½†ç¾å¦‚ä»Šå·²ç¶“æ¶ˆå¤±æˆ–ä¸åŒçš„ä¸€ç¨®æŒ‡æ¨™ã€‚
### 19. ä½¿ç”¨ä¸€å€‹å…§å»ºæŒ‡æ¨™ä¾†å­˜å–æŸå€‹æ™ºæ…§æŒ‡æ¨™æ‰€æ“æœ‰çš„ç‰©ä»¶é€šå¸¸ä¸¦ä¸æ˜¯å€‹å¥½æƒ³æ³•ï¼Œå› ç‚ºæˆ‘å€‘ä¸çŸ¥é“é‚£å€‹ç‰©ä»¶ä½•æ™‚æœƒè¢«æ‘§æ¯€ã€‚
### 20. ä¸è«–æ˜¯shared_ptré‚„æ˜¯unique_ptrï¼Œæˆ‘å€‘éƒ½å¿…é ˆä½¿ç”¨ç›´æ¥åˆå§‹åŒ–çš„æ–¹å¼ã€‚ä¾†å°‡ä»–ç¶åˆ°ä¸€å€‹newæ‰€å›å‚³çš„æŒ‡æ¨™ä¸Šã€‚
```c++
shared_ptr<int> sp1(new int(42));
unique_ptr<int> sp2(new int(42));
```
### 21. unique_pträ¸æ”¯æ´ä¸€èˆ¬çš„æ‹·è²è·ŸæŒ‡å®šã€‚
### 22. é€šéweak_prtå°shared_ptré€²è¡Œç¶å®šï¼Œä¸¦ä¸æœƒå½±éŸ¿è©²shared_ptrçš„è¨ˆæ•¸ã€‚
```c++
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); //ä½¿ç”¨shared_pträ¾†åˆå§‹åŒ–ï¼Œä½†shared_ptrçš„è¨ˆæ•¸å™¨ä¸è®Šã€‚
```
## 24 å‹•æ…‹é™£åˆ—(Dynamic Array)
### 1. å®šç¾©/åˆªé™¤å‹•æ…‹é™£åˆ—ï¼Œå¦‚ä¸‹:
```c++
int *pia = new int[size]; //è¦æ³¨æ„ï¼Œpiaæ‰€æŒ‡çš„æ˜¯é™£åˆ—ä¸­çš„ç¬¬ä¸€å€‹å…ƒç´ 
delete[] pia;
```
### 2. æˆ‘å€‘å¯ä»¥ä½¿ç”¨unique_pträ¾†ç®¡ç†å‹•æ…‹é™£åˆ—:
```c++
unique_ptr<int[]> up(new int[10]);
up.release(); //ç­‰åƒ¹æ–¼delete []
```
### 3. æˆ‘å€‘ä¹Ÿèƒ½é€šéä¸‹æ¨™çš„æ–¹å¼ä¾†å­˜å–unique_ptr:
```c++
for(size_t i = 0; i != 10; ++i)
{
	up[i] = i; //è³¦å€¼
}
```
### 4.é€šå¸¸æˆ‘å€‘ä¸¦ä¸å»ºè­°ä½¿ç”¨shared_pträ¾†ç®¡ç†å‹•æ…‹é™£åˆ—ï¼Œå¦‚æœçœŸçš„è¦ä½¿ç”¨ï¼Œè¦è¨˜å¾—è¨­è¨ˆä¸€å€‹åˆªé™¤å™¨ã€‚
### åŒæ™‚ï¼Œå¦‚æœæˆ‘å€‘è¦å­˜å–å‹•æ…‹é™£åˆ—ä¸­çš„å…ƒç´ ï¼Œä¹Ÿç„¡æ³•ä½¿ç”¨ä¸‹æ¨™ä¾†å­˜å–ï¼Œè€Œæ˜¯è¦ä½¿ç”¨get()å‡½å¼ã€‚
## â­â­â­å¯¦ä½œ:
```c++
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <algorithm>
/*
* è¨­è¨ˆä¸€å€‹æ–‡å­—æŸ¥è©¢ç¨‹å¼
* è®€å–ä¸€ç¯‡æ–‡ç« 
* ä½¿ç”¨è€…è¼¸å…¥ä¸€å€‹å­—è©(ä¸å€åˆ†å¤§å°å¯«)
* è¼¸å‡ºè©²å­—è©ç¸½å…±å‡ºç¾äº†å¹¾æ¬¡
* è¼¸å‡ºè©²å­—è©åœ¨å“ªä¸€è¡Œå‡ºç¾ï¼Œåœ¨è©²è¡Œå‡ºç¾äº†å¹¾æ¬¡ï¼Œä¸¦ä¸”å°å‡ºè©²è¡Œ
* 
*/

/*
* Function:
* 1.Use a vector to store the passage
* 2.Each (index) stroe 1 line
* 3.Seperate the word
* 4.Store the word
* 5.Store the line
* 6.Print the answer
*/

void LookFor_Word(const std::string, std::map<std::string, unsigned>, std::map<unsigned, unsigned>, std::map<unsigned, std::string>);
const std::string User_Input();

class Read_Passage
{
public:
	//using line_Nos = std::vector<std::string>::size_type; //use vector to stroe the passage the line means vec[0],vec[1],vec[2]
	Read_Passage(std::ifstream& input, const std::string search_word); //constructor

private:
	std::vector<std::string> file; //a vector used to store each sentence
	std::map<std::string, unsigned> word_map; //word + total counter
	std::map<unsigned, unsigned> lines_map; //line + line counter(use to count the word occurs in each line)
	std::map<unsigned, std::string> sentence_map; // line + sentence in order to save the sentence
	//We need to notice that map is searched by key not idnex so we can start from 1 which means line 1
};

inline Read_Passage::Read_Passage(std::ifstream& input, const std::string search_word) //the details of the constructor
{
	std::string text = "";

	while (getline(input, text)) //read the sentence line by line
	{
		file.push_back(text); //store the text in each line
		size_t n = file.size(); //the line_Nos
		std::istringstream record(text); //seperate the words in each line
		std::string word; //in order to stroe the word
		while (record >> word) //start to seperate
		{
			std::transform(word.begin(), word.end(), word.begin(), ::tolower); //conver the word to lower
			++word_map[word]; //store each word into the map and for the repeat word the total counter will +1
			if (word == search_word) //check if the word is equal to search_word or not
			{
				++lines_map[n]; //the word is equal to the target and it doesnt jump out the loop so its in the same line / counter+1
			}
			
		}

		sentence_map[n] = text; //store each sentence
	}

	LookFor_Word(search_word, word_map, lines_map, sentence_map); //funciton for looking for the word
	

}

inline const std::string User_Input() //function for user to input the word what they want to search and return it
{

	std::cout << "Please enter the word you want to find in this chapter: " << std::flush;
	std::string search_word = "";

	std::cin >> search_word; //store the word

	std::cout << "The word you want to search is: >>" << search_word << "<<" << std::endl;

	std::transform(search_word.begin(), search_word.end(), search_word.begin(), ::tolower); //conver the word to lower
	return search_word;
}

inline void LookFor_Word(const std::string w, std::map<std::string, unsigned> m, std::map<unsigned, unsigned> l, std::map<unsigned, std::string> sen) //funciton for looking for the word
{
	if (m.find(w) == m.end()) //check if we find the target or not
		std::cout << "We can not find this word in this chapter." << std::endl;

	if (m[w] > 1) //singular(incldue 0) and plura
		std::cout << "There are " << m[w] << " >>" << w << "<< in this chapter totally." << std::endl;
	else
		std::cout << "There is " << m[w] << " >>" << w << "<< in this chapter totally." << std::endl;


	auto lines_beg = l.begin();
	while (lines_beg != l.end()) //start to print the details for each line if we find the word
								//if we dont find the word: lines_beg == l.end()
	{
		std::cout << "(Lines: " << (lines_beg->first) << ")" << " The word: " << ">>" << w << "<< "
			<< "occurs " << lines_beg->second << " time(s)" << std::endl;
		std::cout << sen[lines_beg->first] << std::endl; //print the sentence included the word
		++lines_beg;
	}
	
}


int main()
{
	const std::string serach_word = User_Input();
	
	std::ifstream input("Twilight.txt");
	Read_Passage file(input, serach_word);

	return 0;
}
```
## 25 æ‹·è²æ§åˆ¶:
### 1. æ‹·è²å»ºæ§‹å™¨:
```c++
// æ‹·è²å»ºæ§‹å™¨
class copy_constructor
{

public:

	copy_constructor() { std::cout << "default constructor" << std::endl; }; //defualt
	copy_constructor(const copy_constructor&) { std::cout << "copy constructor" << std::endl; }; //copy

};

int main()
{

	copy_constructor A;
	copy_constructor B(A);
	copy_constructor C = A; //ç­‰åƒ¹æ–¼ä¸Šè¿°


	return 0;
}
```
### 2. ç•¶æˆ‘å€‘ä½¿ç”¨ç›´æ¥åˆå§‹åŒ–æ™‚ï¼Œæ˜¯åœ¨è¦æ±‚ç·¨è­¯å™¨ä½¿ç”¨å‡½å¼åŒ¹é…ï¼Œä¾†é¸æ“‡èˆ‡æä¾›åƒæ•¸ç›¸åŒçš„å»ºæ§‹å™¨ã€‚è€Œæ‹·è²åˆå§‹åŒ–å‰‡æ˜¯åœ¨å°‡å³æ‰‹é‚Šçš„é‹ç®—å…ƒæ‹·è²åˆ°æ­£åœ¨å»ºç«‹çš„ç‰©ä»¶ç•¶ä¸­ã€‚
```c++
// ç›´æ¥åˆå§‹åŒ– / æ‹·è²åˆå§‹åŒ–
void copy_initial(int val)
{
	std::cout << "copy" << std::endl;
}

int main()
{
	std::string s1(10, 's'); //ç›´æ¥åˆå§‹åŒ–
	std::string s2(s1); //ç›´æ¥åˆå§‹åŒ–(æ‹·è²å»ºæ§‹å™¨)
	std::string s3 = s1; //æ‹·è²åˆå§‹åŒ–
	std::string s4 = "ssssssssssssss"; //æ‹·è²åˆå§‹åŒ–
	std::string s5 = std::string(10, 's'); //æ‹·è²åˆå§‹åŒ–

	int value = 5;

	copy_initial(value); // int val = value;
	return 0;
}
```
### 3. æ‹·è²åˆå§‹åŒ–ä¸åªç™¼ç”Ÿåœ¨æˆ‘å€‘ä½¿ç”¨"="æ™‚ã€‚
### å‚³éä¸€å€‹ç‰©ä»¶ä½œç‚ºéåƒè€ƒå‹çš„åƒæ•¸æ™‚ã€‚
### å¾ä¸€å€‹éåƒè€ƒå‹åˆ¥çš„å‡½å¼å›å‚³ç‰©ä»¶æ™‚ã€‚
### ä»¥å¤§æ‹¬è™Ÿåˆå§‹åŒ–ä¸€å€‹é™£åˆ—ä¸­çš„å…ƒç´ æ™‚ã€‚
### ä»¥ä¸Šé€™äº›ä¹Ÿéƒ½æœƒåšæ‹·è²åˆå§‹åŒ–ã€‚
### 4. æ‹·è²æŒ‡å®šé‹ç®—å­:é‡è¼‰çš„é‹ç®—å­æ˜¯ä¸€ç¨®å‡½å¼ï¼Œå…¶åç¨±ç‚ºoperatorå¾Œé¢åŠ ä¸Šä¸€å€‹è¢«å®šç¾©çš„é‹ç®—å­ç¬¦è™Ÿï¼Œå¦‚ä¸‹:
```c++
// é‡è¼‰é‹ç®—å­
class Foo
{
public:
	Foo(const std::string s, const int i) : ss(s), ii(i) { std::cout << "Initialized" << std::endl; };
	Foo& operator=(const Foo&);
	

private:
	std::string ss;
	int ii;
};

Foo& Foo::operator=(const Foo& F)
{
	ss = F.ss;
	ii = F.ii;

	return *this;
}
```
### 5. ç‚ºäº†è·Ÿå…§å»ºå‹åˆ¥ä¸€è‡´ï¼ŒæŒ‡å®šé‹ç®—å­é€šå¸¸å›å‚³ä¸€å€‹åƒè€ƒæŒ‡å‘å·¦é‚Šé‹ç®—å…ƒã€‚
### 6. è§£æ§‹å™¨:è§£æ§‹å™¨æœƒå°‡ä¸€å€‹ç‰©ä»¶ç”¨åˆ°çš„è³‡æºé€²è¡Œé‡‹æ”¾ï¼Œä¸¦æ‘§æ¯€è©²ç‰©ä»¶éstaticçš„è³‡æ–™æˆå“¡ã€‚
### 7. è§£æ§‹å™¨æ²’æœ‰å›å‚³å€¼ä¹Ÿä¸æ¥å—åƒæ•¸ã€‚è€Œåˆå› ç‚ºä¸æ¥å—åƒæ•¸çš„åŸå› ï¼Œæ‰€ä»¥è§£æ§‹å™¨æ²’æœ‰é‡è¼‰ã€‚
```c++
// è§£æ§‹å™¨
class Foo
{

public:
	~Foo() {};

};
```
### 8. Three Rules:ä¸‰å€‹åŸºæœ¬é‹ç®—ç”¨ä¾†æ§åˆ¶ç‰©ä»¶çš„æ‹·è²:æ‹·è²å»ºæ§‹å™¨ã€æ‹·è²æŒ‡å®šé‹ç®—å­ï¼Œä»¥åŠè§£æ§‹å™¨ã€‚
### 9. ä¸€èˆ¬ä¾†èªªï¼Œå¦‚æœæœ‰è§£æ§‹å™¨ï¼Œé‚£éº¼å°±éœ€è¦æ‹·è²å»ºæ§‹å™¨è·Ÿæ‹·è²å»ºæ§‹å™¨ã€‚è€Œå¦‚æœæœ‰æ‹·è²å»ºæ§‹å™¨ä¹Ÿæœƒéœ€è¦æ‹·è²æŒ‡å®šé‹ç®—å­ï¼Œåä¹‹äº¦ç„¶ã€‚
### 10. ä½†è¦è¨˜å¾—ï¼Œæœ‰æ‹·è²å»ºæ§‹å™¨è·Ÿæ‹·è²å»ºæ§‹å™¨å»ä¸ä¸€å®šéœ€è¦è§£æ§‹å™¨ã€‚
### 11. é¡å€¼æ‹·è²:
```c++
//é¡å€¼æ‹·è²
class value_like
{
public:
	value_like(const std::string& s = std::string()) : //initialize
		ps(new std::string(s)), i(0) 
	{
		std::cout << "Initialized: " << *ps << " " << i << std::endl;
	}; // ps need to be deleted

	value_like(const value_like& val) : //copy 
		ps(new std::string(*val.ps)), i(val.i) 
	{
		std::cout << "Copy: " << *ps << " " << i << std::endl;
	}; //in order to avoid double or more pointers point to the same object, we need to dereference to create a new object
												
	value_like& operator=(const value_like&);
	~value_like() //deconstructor
	{
		delete ps;
	};
private:

	std::string* ps;
	int i;

};

value_like& value_like::operator=(const value_like& rhs) // after we initialized we'll use assign
{
	auto temp = new std::string(*(rhs.ps)); //dereference to access its value
	delete ps;
	ps = temp;
	i = rhs.i;
	std::cout << "Assigned: " << *(this->ps) << " " << this->i << std::endl;

	return *this; // value_like* this = &value (value_like value)
}

int main()
{

	value_like test1("Hello"); //initialize
	value_like test2(test1); //copy
	value_like test3 = test1; //copy


	value_like test4("Hi"); //initialize
	test4 = test1; //assign

	return 0;
}
```
### 12. åœ¨å¯«æŒ‡å®šé‹ç®—å­æ™‚ï¼Œæˆ‘å€‘éœ€è¦åšçš„å°±æ˜¯å°‡å³æ‰‹é‚Šçš„é‹ç®—åŸå…ˆæ‹·è²åˆ°ä¸€å€‹æš«å­˜ç‰©ä»¶ä¸Šï¼Œé‚£éº¼æˆ‘å€‘å°±å¯ä»¥å®‰å¿ƒçš„æ‘§æ¯€ç‰©ä»¶äº†ã€‚
### 13. é¡æŒ‡æ¨™æ‹·è²:è¦è®“ä¸€å€‹é¡åˆ¥è¡¨ç¾çš„åƒæŒ‡æ¨™ï¼Œæœ€ç°¡å–®çš„æ–¹å¼å°±æ˜¯ä½¿ç”¨æ™ºæ…§æŒ‡æ¨™(shared_ptr)çš„ç®¡ç†ç³»çµ±ã€‚å› ç‚ºshared_ptrå°±æ˜¯ä¾é è¿½è¹¤åˆ°åº•æœ‰å¤šå°‘ä½¿ç”¨è€…å…±ç”¨æ‰€æŒ‡çš„ç‰©ä»¶ï¼Œä¾†æ±ºå®šæ˜¯å¦æ‘§æ¯€è©²ç‰©ä»¶ã€‚
```c++
//é¡æŒ‡æ¨™æ‹·è²
class pointer_like
{
public:
	pointer_like(const std::string& s = std::string()) : //initialize
		ps(new std::string(s)), i(0), use(new std::size_t(1))
	{
		std::cout << "Initialized: " << *ps << " " << i << " Counter: " << *use << std::endl;
	}; // ps need to be deleted

	pointer_like(const pointer_like& val) : //copy 
		ps(new std::string(*val.ps)), i(val.i), use(val.use)
	{
		++(*use);
		std::cout << "Copy: " << *ps << " " << i << " Counter: " << *use << std::endl;
	}; //in order to avoid double or more pointers point to the same object, we need to dereference to create a new object

	pointer_like& operator=(const pointer_like&);
	~pointer_like() //deconstructor
	{
		if (--(*use) == 0) //when there are no the other users point to the object we just can delete
		{
			delete ps;
			delete use;
		}
		
	};
private:

	std::string* ps;
	int i;
	std::size_t* use;

};

pointer_like& pointer_like::operator=(const pointer_like& rhs) // after we initialized we'll use assign
{
	++(*(rhs.use));
	if (--(*use) == 0) // deconstructor:since this is assigning so the lavalue will be deleted and going to be assign
	{
		delete ps; //this->ps
		delete use; //this->use
		//delete i //auto delete
	}

	ps = rhs.ps; //dereference to access its value
	i = rhs.i;
	use = rhs.use;
	std::cout << "Assigned: " << *(this->ps) << " " << this->i << " Counter: " << *(this->use) << std::endl;

	return *this; // value_like* this = &value (value_like value)
}

int main()
{
	pointer_like test1("Hello"); //initialize
	pointer_like test2(test1); //copy
	pointer_like test3 = test1; //copy


	pointer_like test4("Hi"); //initialize
	test4 = test1; //assign

	return 0;
}
```
### 14. å¦‚æœæˆ‘å€‘è¨ˆç•«å°‡é¡åˆ¥ç”¨æ–¼é‡æ–°æ’åˆ—å…ƒç´ çš„æ¼”ç®—æ³•ï¼Œé‚£å®šç¾©ä¸€å€‹swapæ˜¯å€‹å¥½ä¸»æ„ã€‚
```c++
//Swap function
//copy and swap

class value_like
{
public:
	friend void swap(value_like&, value_like&);
	value_like(const std::string& s = std::string()) : //initialize
		ps(new std::string(s)), i(0)
	{
		std::cout << "Initialized: " << *ps << " " << i << std::endl;
	}; // ps need to be deleted

	value_like(const value_like& val) : //copy 
		ps(new std::string(*val.ps)), i(val.i)
	{
		std::cout << "Copy: " << *ps << " " << i << std::endl;
	}; //in order to avoid double or more pointers point to the same object, we need to dereference to create a new object

	value_like& operator=(value_like);
	~value_like() //deconstructor give each class a independent object so we can delete them each time
	{
		delete ps;
	};
private:

	std::string* ps;
	int i;

};

value_like& value_like::operator=(value_like rhs) // rememebr that rhs should not be a const
{
	swap(*this, rhs); //the swap we designed

	return *this; // value_like* this = &value (value_like value)
}

inline void swap(value_like& v1, value_like& v2) //this is my own swap
{
	
	std::swap(v1.ps, v2.ps); //this is the swap in standard library
	std::swap(v1.i, v2.i);

	std::cout << "left: " << *(v1.ps) << " " << v1.i << " right: " << *(v2.ps) << " " << v2.i << std::endl;
}

int main()
{

	value_like test1("Hello"); //initialize
	value_like test2(test1); //copy
	value_like test3 = test1; //copy


	value_like test4("Hi"); //initialize
	test4 = test1; //assign -> swap

	value_like test5("Swap test");

	swap(test1, test5);

	return 0;
}
```
## â­â­â­å¯¦ä½œ:
```c++
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include <map>
#include <set>


//è¨­è¨ˆä¸€å€‹éƒµä»¶ç®¡ç†ç³»çµ±
/*
* 1. Folder:ç”¨ä¾†å„²å­˜éƒµä»¶
* 2. ä¸€å€‹éƒµä»¶å¯ä»¥å„²å­˜åœ¨å¤šå€‹folderå…§
* 3. å¯ä»¥å–®ç¨åœ¨æŸå€‹folderåˆªé™¤éƒµä»¶ï¼Œä½†ä¸å½±éŸ¿æ•´é«”
* 4. å¯ä»¥ç›´æ¥åˆªé™¤éƒµä»¶(å¾å…¨éƒ¨çš„folderçš„)
*/



class Folder
{
public:

	friend class Message;

	Folder(const std::string& name) :
		folder_name(new std::string(name))
	{
		std::cout << "Folder " << name << " is created." << std::endl;
		std::cout << "-----------------------------" << std::endl;
	} //Constructor


	void Add_Msg(Message& msg); //adding mail into folder
	void Remove_From_Folder(Message& msg); //remove mail from folder
	void show_folder(); //show the details of the folder

private:

	std::string* folder_name;
	std::set<Message*> mail; //use to store the pointer which points to the mail (save mail)

};

class Message
{
public:

	friend class Folder;

	Message(const std::string& mail_name, const std::string& mail_contents):
		name(new std::string(mail_name)), content(new std::string(mail_contents))
	{
		std::cout << "Mail: " << mail_name << " is created." << std::endl;
		std::cout << "-----------------------------" << std::endl;
	} //Constructor

	Message(const Message&); //copy
	Message& operator=(const Message&); //assign

	~Message() 
	{ 
		if (!*(this->removedornot))
		{
			std::cout << *(this->name) << " is destructing..." << std::endl;
			for (auto folder : in_folder)
			{
				folder->mail.erase(this);
			}
			delete name, content;
			in_folder.clear();
		}
		else
			;
	}; //Destructor

	void Remove_Message(); //Remove the mail from all folders
	void show_mail(); //show the details of the mail


private:

	std::string* name;
	std::string* content;
	std::set<Folder*> in_folder; //store the pointer which points to the folder that stroes this mail
	bool* removedornot = new bool(false); //used to check the mail is removed or not
};

Message::Message(const Message& mail): //copy
	name(new std::string(*(mail.name))), content(new std::string(*(mail.content))){}

Message& Message::operator=(const Message& rhs) //assign
{
	auto name_temp = new std::string(*(rhs.name));
	auto content_temp = new std::string(*(rhs.content));
	delete name, content;
	name = name_temp;
	content = content_temp;
	in_folder = rhs.in_folder;

	return *this;
}

inline void Message::Remove_Message()
{
	std::cout << "Removing mail... " << *(this->name) << " from: " << std::flush;
	
	std::size_t ctr = 1; //used to check run throw the all folders or not

	for (auto folder : in_folder) //run throw the all folders that store this mail and use them to remove this mail
	{
		std::cout << *(folder->folder_name) << ((ctr < in_folder.size()) ? ", " : ".") << std::flush;
		folder->mail.erase(this);
		++ctr;
	}
	delete name, content;
	in_folder.clear();
	*(this->removedornot) = true;
	
}

inline void Message::show_mail()
{
	std::cout << "Mail: " << *(this->name) << std::endl;
	std::cout << "Contents: " << *(this->content) << std::endl;
	std::cout << "-----------------------------" << std::endl;

	auto beg = (this->in_folder).begin();
	while (beg != (this->in_folder).end())
	{
		std::cout << "Mail is stored in folder: " << *((*beg)->folder_name) << std::endl;
		std::cout << "-----------------------------" << std::endl;
		++beg;
	}

}



inline void Folder::Add_Msg(Message& msg)
{
	mail.insert(&msg);
	msg.in_folder.insert(this);
}
inline void Folder::Remove_From_Folder(Message& msg)
{
	mail.erase(&msg);
	msg.in_folder.erase(this);
}

inline void Folder::show_folder()
{
	std::cout << "Folder: " << *(this->folder_name) << std::endl;
	std::cout << "The mail in this folder: " << std::endl;

	auto beg = (this->mail).begin();
	unsigned ctr = 1;
	while (beg != (this->mail).end())
	{
		std::cout << ctr++ << ": " << *((*beg)->name) << std::endl;
		++beg;
	}

}

int main()
{

	//Create 2 folders
	Folder folder1("first_folder");
	Folder folder2("second_folder");

	//Create 3 mails
	Message msg1("First mail", "Hello, how are you?");
	Message msg2("Second mail", "Test");
	Message msg3("Third mail", "Hi");


	//adding mails to folders
	folder1.Add_Msg(msg1);
	folder1.Add_Msg(msg2);
	folder1.Add_Msg(msg3);

	folder2.Add_Msg(msg1);
	folder2.Add_Msg(msg2);

	//check details
	msg1.show_mail();
	msg2.show_mail();
	msg3.show_mail();
	folder1.show_folder();

	std::cout << std::endl;
	folder2.show_folder();
	std::cout << std::endl;


	//Remove mail from folder
	folder1.Remove_From_Folder(msg2);
	folder1.show_folder();
	std::cout << std::endl;
	msg2.show_mail();
	std::cout << std::endl;
	std::cout << std::endl;

	//Remove the whole mail
	msg1.Remove_Message();
	std::cout << std::endl;
	folder1.show_folder();
	std::cout << std::endl;


	return 0;
}
```
### 15. ç§»å‹•å»ºæ§‹å™¨(move constructor):å°‡è³‡æºå¾æ‰€çµ¦çš„ç‰©ä»¶"ç§»å‹•"åˆ°æ­£åœ¨å»ºæ§‹çš„ç‰©ä»¶(æ‹·è²æŒ‡æ¨™ï¼Œè€Œéæ‹·è²é‚£äº›å­—å…ƒ)ã€‚
## â­â­â­å¯¦ä½œ:
```c++
//è¨­è¨ˆä¸€å€‹å°å‹çš„vector

class strVec
{
public:
	strVec():
		elements(nullptr), first_free(nullptr), cap(nullptr) {}
	strVec(const strVec&);
	strVec& operator=(const strVec&);

	~strVec()
	{
		free();
	}

	void push_back(const std::string&);
	size_t size() const
	{
		return first_free - elements;
	}

	size_t capacity() const
	{
		return cap - elements;
	}

	std::string* begin() const
	{
		return elements;
	}

	std::string* end() const
	{
		return first_free;
	}
private:
	
	static std::allocator<std::string> alloc; //ç”¨ä¾†é…ç½®ç©ºè¨˜æ†¶é«”
	void check_alloc_size() //æª¢æŸ¥å®¹é‡
	{
		if (size() == capacity()) //å¦‚æœå„²å­˜å…ƒç´ æ•¸é‡å·²ç¶“ç­‰æ–¼å®¹é‡å¤§å°
			reallocate(); //é‡æ–°åˆ†é…
	}
	std::pair<std::string*, std::string*> copy_alloc(const std::string*, const std::string*); //copy

	void free();
	void reallocate();

	std::string* elements; //ç¬¬ä¸€å€‹å…ƒç´ 
	std::string* first_free; //æœ€å¾Œä¸€å€‹å…ƒç´ çš„ä¸‹ä¸€å€‹ç©ºä½ç½®
	std::string* cap; //æœ€å¾Œä¸€å€‹ç©ºä½ç½®

};

std::allocator<std::string> strVec::alloc;

void strVec::push_back(const std::string& s)
{
	check_alloc_size(); //åªæœ‰å¢åŠ å…ƒç´ æ™‚æ‰æœ‰å¯èƒ½å¤§å°ä¸è¶³
	alloc.construct(first_free++, s); //å¾ç¬¬ä¸€å€‹ç©ºä½ç½®é–‹å§‹æ·»åŠ å…ƒç´ 
}

std::pair<std::string*, std::string*> strVec::copy_alloc(const std::string* b, const std::string* e) //used to copy
{
	auto data = alloc.allocate(e - b); //åˆ†é…ä¸€å¡Šç©ºé–“çµ¦ç›®æ¨™ç‰©ä»¶
	return { data, std::uninitialized_copy(b,e,data) }; //å›å‚³ç›®æ¨™ç‰©ä»¶çš„ç¬¬ä¸€å€‹å…ƒç´ è·Ÿå°¾å¾Œ
														//uninitialized_copy(b,e,data)æŠŠbåˆ°eè¤‡è£½åˆ°dataè£¡é¢
}

void strVec::free()
{
	if (elements) // if there are elements in the vector means that begin is not null
	{
		for (auto p = first_free; p != elements;) //delete the element from the last element
			alloc.destroy(--p);

		alloc.deallocate(elements, cap - elements); //deallocate from element to cap (begin to end)
	}
}


strVec::strVec(const strVec& v) //è¤‡è£½
{
	auto new_data = copy_alloc(v.begin(), v.end());
	elements = new_data.first; // å–new_dataçš„ç¬¬ä¸€å€‹å…ƒç´  å¯ä»¥çœ‹71è¡Œ
	first_free = cap = new_data.second; //this is copy so cap will equal to end and first_free
}


strVec& strVec::operator=(const strVec& rhs)
{
	auto data = copy_alloc(rhs.begin(), rhs.end());
	free();
	elements = data.first;
	first_free = cap = data.second;

	return *this;
}

void strVec::reallocate()

{
	auto new_capacity = (size() == 0) ? 1 : size() * 2; //ç¢ºèªæ˜¯å¦ç‚ºæ–°çš„vector
	auto new_data = alloc.allocate(new_capacity); //åˆ†é…æ–°çš„ç©ºé–“

	auto dest = new_data; //æŒ‡å‘æ–°ç©ºé–“çš„ç¬¬ä¸€å€‹å…ƒç´ 
	auto elem = elements; //æŒ‡å‘èˆŠç©ºé–“çš„ç¬¬ä¸€å€‹å…ƒç´ 
	for (size_t i = 0; i != size(); ++i)
	{
		alloc.construct(dest++, std::move(*elem++)); //å¾èˆŠç©ºé–“ç§»å‹•å…ƒç´ åˆ°æ–°ç©ºé–“
	}
	free(); //é‡‹æ”¾èˆŠç©ºé–“
	elements = new_data; //æ›´æ–°è³‡æ–™æŒ‡å‘æ–°ç©ºé–“
	first_free = dest;
	cap = elements + new_capacity;

}
```







## â­è£œå……
### 1. åœ¨ostreamä¸­å…¶å¯¦é‚„åŒ…å«äº†å¦å¤–å…©å€‹ç‰©ä»¶ï¼Œcerrè·Ÿclogï¼Œæˆ‘å€‘çµ±ç¨±ä»–å€‘çš„æ¨™æº–éŒ¯èª¤(standard error):
### å…¶ä¸­cerræ˜¯ç”¨ä¾†ç™¼å‡ºè­¦å‘Šå’ŒéŒ¯èª¤è¨Šæ¯ï¼Œclogå‰‡æ˜¯ç”¨ä¾†è¨˜éŒ„ç¨‹å¼åŸ·è¡Œéç¨‹ä¸­çš„ä¸€èˆ¬è³‡è¨Šã€‚
### 2. "extern"ä¸æ˜¯å®šç¾©ï¼Œæ˜¯å®£å‘Šï¼Œè®“æˆ‘å€‘å¾å¤–éƒ¨å¼•ç”¨å…¶å®ƒç¨‹å¼ç¢¼ä¸­æ‰€å®šç¾©çš„é"static"è®Šæ•¸ã€‚
### 3. ç•¶æˆ‘å€‘åœ¨è§€å¯Ÿä¸€å€‹è®Šæ•¸çš„å®šç¾©æ™‚ï¼Œå¾å³é‚Šå‘å·¦çœ‹å°±å°äº†!
### 4. å¯ä»¥æŠŠè¿­ä»£å™¨æƒ³æˆæ˜¯ä¸€å€‹pointerï¼ŒæŒ‡å‘indexæ‰€è™•çš„ä½ç½®ã€‚
### 5. åœ¨ä½¿ç”¨"null"è¿°å¥æ™‚ï¼Œéƒ½æ‡‰è©²åŠ ä¸Šè¨»è§£ï¼Œè®“é–±è®€ç¨‹å¼ç¢¼çš„äººçŸ¥é“è©²è¡Œæ˜¯åˆ»æ„çœç•¥çš„ã€‚
### 6. åœ¨æˆ‘å€‘ä½¿ç”¨è¿´åœˆæ™‚ï¼Œå¦‚æœä¸ç¢ºå®šåˆ°åº•è¦åŸ·è¡Œå¤šå°‘æ¬¡ï¼Œåˆæˆ–è€…å·²ç¶“çŸ¥é“æœƒåŸ·è¡Œéå¸¸å¤šæ¬¡ï¼Œé‚£æˆ‘å€‘å°±éƒ½æœƒç”¨whileã€‚
### 7. åœ¨ä¸€å€‹åƒè€ƒä¸Šé€²è¡Œé‹ç®—ï¼Œå…¶å¯¦å°±æ˜¯åœ¨å°è©²åƒè€ƒæ‰€ç¶å®šçš„ç‰©ä»¶é€²è¡Œé‹ç®—ã€‚
### 8. å¦‚æœä½ ä¸æ‰“ç®—åœ¨ä¸€å€‹å‡½å¼å…§éƒ¨ä¿®è©²å¼•ç”¨çš„åƒæ•¸ï¼Œè«‹å¦¥å–„ä½¿ç”¨constã€‚
### 9. åœ¨C++ä¸­åç¨±çš„æŸ¥æ‰¾å…ˆæ–¼å‹åˆ¥æª¢æŸ¥ã€‚
### 10. ç•¶ä½ çœ‹åˆ°ä¸€å€‹å‡½å¼è¢«ç•¶æˆåƒæ•¸æ™‚ï¼Œå®ƒæœƒè‡ªå‹•åœ°è¢«è½‰æ›ç‚ºæŒ‡æ¨™ã€‚
### 11. ç·¨è­¯å™¨æœƒå…ˆåšå®£å‘Šç„¶å¾Œæ‰è™•ç†å‡½å¼ä¸»é«”ã€‚
### 12. referenceè·Ÿconstéƒ½æ˜¯ä¸èƒ½è¢«è³¦å€¼çš„ã€‚
### 13. æ§‹é€ å‡½å¼ä¸æœƒæœ‰å›å‚³ã€‚
### 14. ä¸€å®šè¦è¨˜å¾—ï¼Œå°æ–¼IOç‰©ä»¶æ˜¯ä¸èƒ½æ‹·è²çš„ï¼Œåªèƒ½ç”¨åƒè€ƒã€‚
### 15. åªè¦æ˜¯keyå°±ä¸èƒ½ä¿®æ”¹ã€‚
### 16. ä¸€å®šè¦è¨˜å¾—ï¼Œä»»ä½•constç‰©ä»¶éƒ½å¿…é ˆè¢«åˆå§‹åŒ–ã€‚
### 17. ç•¶æˆ‘å€‘æœ‰å¤šå€‹classè¦å…±ç”¨ä¸€å€‹ç‰©ä»¶æ™‚ï¼Œå°±å¯ä»¥ä½¿ç”¨shared_ptrã€‚


# LeetCode
### Exercise 1
>Binary Search(äºŒåˆ†æœå°‹æ³•):Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
### äºŒåˆ†æœå°‹æ³•æ˜¯ä¸€ç¨®åœ¨"æœ‰åº"æ•¸åˆ—æœå°‹ç‰¹å®šå…ƒç´ (æ•¸å€¼)çš„æ¼”ç®—æ³•ï¼Œé€šéå°‡é™£åˆ—æ‹†åŠï¼Œå¾æœ€ä¸­é–“çš„å…ƒç´ é–‹å§‹å°‹æ‰¾ç›®æ¨™å€¼ï¼Œå…¶å¹³å‡æ™‚é–“è¤‡é›œåº¦(Time Complexity)ç‚º:O(logn)ã€‚
### æ ¸å¿ƒæ¦‚å¿µ:
1. å·¦é–‰å³é–‰[left, right]:è¡¨ç¤ºå€é–“åŒ…å«å…©é»æ¥µç«¯å€¼leftä»¥åŠrightã€‚
2. å·¦é–‰å³é–‹[left, right):è¡¨ç¤ºå€é–“ä¸åŒ…å«å³æ–¹æ¥µç«¯å€¼rightï¼Œåä¹‹äº¦ç„¶ã€‚
3. å€é–“ä¸è®Šé‡:è¡¨ç¤ºå€é–“åˆå§‹è¨­å®šç‚ºå·¦é–‰å³é–‰ï¼Œé‚£éº¼åœ¨æ¥ä¸‹ä¾†çš„åŸ·è¡Œéç¨‹ä¸­ï¼Œå°±ç¶­æŒå·¦é–‰å³é–‰ï¼Œå…¶ä»–ä¾‹å­ä¹Ÿæ˜¯å¦‚æ­¤ã€‚

### ç¨‹å¼ç¢¼ç¯„ä¾‹1(å·¦é–‰å³é–‰):
```python
nums = [0, 1, 3, 5, 8, 7, 11] /*åˆå§‹æ•¸åˆ—*/
left, right = 0, len(nums)-1
target = 2 /*ç›®æ¨™å€¼*/
while(left <= right):
   middle = (left + right)/2 /*å–ä¸­é–“å€¼*/
   if(nums[middle] > target): /*ä¸­é–“å€¼å¤§æ–¼ç›®æ¨™å€¼ï¼Œå¾å·¦å€é–“é–‹å§‹é‡æ–°å°‹æ‰¾*/
       right = middle - 1 /*å°‡ä¸­é–“å€¼å¾€å·¦ä¸€æ ¼é‡æ–°å°‹æ‰¾*/
   elif(nums[middle] < target): /*ä¸­é–“å€¼å°æ–¼ç›®æ¨™å€¼ï¼Œå¾å³å€é–“é–‹å§‹é‡æ–°å°‹æ‰¾*/
       left = middle + 1 /*å°‡ä¸­é–“å€¼å¾€å³ä¸€æ ¼é‡æ–°å°‹æ‰¾*/
   else: /*ä¸­é–“å€¼èˆ‡ç›®æ¨™å€¼ç›¸ç­‰ï¼Œè¡¨ç¤ºæ‰¾åˆ°äº†*/
       return middle

return -1
```
### ç¨‹å¼ç¢¼ç¯„ä¾‹2(å·¦é–‰å³é–‹):
```python
nums = [0, 1, 3, 5, 8, 7, 11] /*åˆå§‹æ•¸åˆ—*/
left, right = 0, len(nums)
target = 2 /*ç›®æ¨™å€¼*/
while(left < right):
   middle = (left + right)/2 /*å–ä¸­é–“å€¼*/
   if(nums[middle] > target): /*ä¸­é–“å€¼å¤§æ–¼ç›®æ¨™å€¼ï¼Œå¾å·¦å€é–“é–‹å§‹é‡æ–°å°‹æ‰¾*/
       right = middle /*å¾å°‡ä¸­é–“å€¼é–‹å§‹é‡æ–°å°‹æ‰¾*/
   elif(nums[middle] < target): /*ä¸­é–“å€¼å°æ–¼ç›®æ¨™å€¼ï¼Œå¾å³å€é–“é–‹å§‹é‡æ–°å°‹æ‰¾*/
       left = middle + 1 /*å°‡ä¸­é–“å€¼å¾€å³ä¸€æ ¼é‡æ–°å°‹æ‰¾*/
   else: /*ä¸­é–“å€¼èˆ‡ç›®æ¨™å€¼ç›¸ç­‰ï¼Œè¡¨ç¤ºæ‰¾åˆ°äº†*/
       return middle

return -1
```
>Solution:
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1 #[left, right]
        while(left <= right):
            middle = (left + right)//2
            if(nums[middle] > target): #left side
                right = middle - 1
            elif(nums[middle] < target): #right side
                left = middle + 1
            else:
                return middle # The Index of the target
            
        return -1
```
â˜ï¸[LeetCodeé€£çµ](https://leetcode.com/problems/binary-search/description/)
â˜ï¸[My_LeetCode_Sol](https://github.com/littleyu0820/LeetCode_Exercises/blob/main/Exercise/Binary_Search.py)

### Exercise(æ‡‰ç”¨ç·´ç¿’)
>Search Insert Position(æœç´¢æ’å…¥ä½ç½®):Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
### æ€è€ƒé‚è¼¯: èˆ‡äºŒåˆ†æœå°‹æ³•æœ‰ç•°æ›²åŒå·¥ä¹‹å¦™ï¼Œä½†éœ€è¦é¡å¤–åˆ¤å®šæ˜¯å¦æœ‰æ‰¾åˆ°ç›®æ¨™å€¼ï¼Œå¦‚æœæ²’æœ‰æ‰¾åˆ°ï¼Œå‰‡æ ¹æ“šç›®æ¨™å€¼çš„å¤§å°ä¾†åˆ¤æ–·è©²æ”¾åœ¨å“ªè£¡ã€‚
>Solution:
```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) 
    {
       //1.æ‰¾æ±è¥¿
       //2.æœ‰åºçš„é™£åˆ—
       //3.ä½¿ç”¨binary search
        int left = 0;
        int right = nums.size() - 1;
        int mid = 0;
        while(left <= right) //start to search
        {
            mid = (left + right) / 2; //ä¸­é–“å€¼

            if(nums[mid] < target) //ç­”æ¡ˆåœ¨å³å€é–“æˆ–ä¸å­˜åœ¨
            {
                left = ++mid;
            }
            else if(nums[mid] > target) //ç­”æ¡ˆåœ¨å·¦å€é–“æˆ–ä¸å­˜åœ¨
            {
                right = --mid;
            }
            else
            {
                return mid;
            }
        }
        mid = (left + right) / 2;
        if(nums[mid] > target && mid == 0) //ç­”æ¡ˆåœ¨å·¦å€é–“
        {
            return mid;
        }
        else
        {
            return (nums[mid] < target) ? ++mid : --mid;
        }
    }
};
```
â˜ï¸[LeetCodeé€£çµ](https://leetcode.com/problems/search-insert-position/)
â˜ï¸[My_LeetCode_Sol](https://github.com/littleyu0820/Interview_Leetode/blob/main/Exercise/Search%20Insert%20Position.cpp)

### Exercise 2
>Remove Element(ç§»é™¤å…ƒç´ ):Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.
### æ ¸å¿ƒæ¦‚å¿µ:
1. æ•¸åˆ—æ˜¯ä¸€å€‹"é€£çºŒ"çš„é¡å‹ç›¸è¿‘çš„å…ƒç´ é›†åˆã€‚
2. æ‰€è¬‚ç§»é™¤ï¼Œä¸¦ä¸æ˜¯åˆªé™¤ï¼Œè€Œæ˜¯å°ç›®æ¨™å…ƒç´ é€²è¡Œ"è¦†è“‹"ã€‚
3. åœ¨å„ç¨®ç¨‹å¼èªè¨€ä¸­ï¼Œç§»é™¤å…ƒç´ å¾Œï¼Œå–å…¶é•·åº¦(len(nums))ï¼Œç¢ºå¯¦æœƒæ¸›å°ï¼Œä½†åœ¨å¯¦éš›ç©ºé–“ä¸Šï¼Œå…¶å¯¦é™£åˆ—çš„æ•´é«”ç©ºé–“å¤§å°ä¸è®Šã€‚

### ç¨‹å¼ç¢¼ç¯„ä¾‹1(å¿«æ…¢æŒ‡é‡æ³•):
### æ€è€ƒé‚è¼¯:é€šéå¿«æŒ‡é‡ç§»å‹•ä¾†å°‹æ‰¾ç›®æ¨™å€¼ï¼Œå¦‚æœæ²’æ‰¾åˆ°ï¼Œå‰‡å°‡å¿«æŒ‡é‡æ‰€åœ¨ä½ç½®çš„å€¼è³¦çµ¦æ…¢æŒ‡é‡ï¼Œæ‰¾åˆ°äº†çš„è©±å‰‡å¿½ç•¥ï¼Œç¹¼çºŒå‘å¾Œç§»å‹•ã€‚
>Solution:
```python
nums = [1, 2, 3, 4, 5]  /*åˆå§‹æ•¸åˆ—*/
target = 3 /*ç§»é™¤ç›®æ¨™*/
pointer_fast = 0 /*ç”¨ä¾†æ‰¾å°‹è¦åˆªé™¤çš„æ•¸å€¼*/ /*å¦‚æœæ²’æ‰¾åˆ°ï¼Œå‰‡æŠŠç•¶å‰æ•¸å€¼çµ¦åˆ°æ…¢æŒ‡é‡ä¸Š*/
pointer_slow = 0 
size = len(nums)
while(pointer_fast < size): /*åœ¨æ•¸åˆ—å…§ç§»å‹•*/
    if(nums[pointer_fast] != target):
        nums[pointer_slow] = nums[pointer_fast]
        pointer_slow += 1
    pointer_fast += 1

return pointer_slow, nums
```
### ç¨‹å¼ç¢¼ç¯„ä¾‹2(æ™®é€šæ€è·¯):
>Solution:
```python
nums = [1, 2, 3, 4, 5]  /*åˆå§‹æ•¸åˆ—*/
target = 3 /*ç§»é™¤ç›®æ¨™*/
counter = 0
size = len(nums)
while(counter < size): /*åœ¨æ•¸åˆ—å…§ç§»å‹•*/
    if(nums[counter] = target): /*æ‰¾åˆ°ç›®æ¨™å€¼*/
        for(i in range(counter+1, size): /*è¦†è“‹è©²å…ƒç´ ï¼Œå…¶å¾Œæ‰€æœ‰å…ƒç´ å‘å·¦å¹³ç§»ä¸€æ ¼*/
            nums[i-1] = nums[i]
        counter -= 1 /*å‘å·¦å¹³ç§»*/
        size -= 1 /*å¿½ç•¥è¢«è¦†è“‹å…ƒç´ */
    counter += 1

return counter, nums
```
â˜ï¸[LeetCodeé€£çµ](https://leetcode.com/problems/remove-element/description/)
â˜ï¸[My_LeetCode_Sol](https://github.com/littleyu0820/Interview_Leetode/blob/main/Exercise/Remove_Element.py)

### Exercise 3
>Squares of a Sorted Array(æœ‰åºé™£åˆ—çš„å¹³æ–¹):Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.
### ç¨‹å¼ç¢¼ç¯„ä¾‹(é›™æŒ‡é‡æ³•):
### æ€è€ƒé‚è¼¯:æ‰€è¬‚çš„æœ‰åºé™£åˆ—ï¼Œå³ä»£è¡¨å…¶æœ€å¤§å€¼èˆ‡æœ€å°å€¼å¿…ç„¶æœƒå‡ºç¾åœ¨å·¦å³å…©å€‹ç«¯é»ã€‚åœ¨é€™æ¨£çš„å‰æä¸‹ï¼Œå¦‚æœæˆ‘å€‘å°‡æ•´å€‹é™£åˆ—åšå¹³æ–¹ï¼Œæƒ³ç•¶ç„¶ï¼Œæœ€å¤§å€¼ä¹Ÿå¿…ç„¶æœƒå‡ºç¾åœ¨å·¦å³å…©ç«¯ã€‚
>Solution:
```python
left_point = 0
right_point = len(nums) - 1
size = len(nums)
new_nums = [float('inf')] * size # the new array to save the results
final = size - 1

while(left_point <= right_point): #left_point +1 or right_point -1 (moving)
	if(nums[left_point]**2 <= nums[right_point]**2):
		new_nums[final] = nums[right_point]**2
		right_point -= 1
	else:
		new_nums[final] = nums[left_point]**2
            	left_point += 1

        final -= 1 #save the  results from the last        
    return new_nums
```
```python
new_nums = [float('inf')] * size # the new array to save the results
final = size - 1
```
### ç¨‹å¼ç¢¼è§£é‡‹:å»ºç«‹ä¸€å€‹æ–°é™£åˆ—ç”¨ä¾†å­˜å–å¹³æ–¹å¾Œçš„å€¼ï¼ŒåŒæ™‚å­˜å–æ–¹å‘æ˜¯ç”±å¾Œå¾€å‰ã€‚
```python
if(nums[left_point]**2 <= nums[right_point]**2):
	new_nums[final] = nums[right_point]**2
	right_point -= 1
else:
	new_nums[final] = nums[left_point]**2
	left_point += 1 
```
### ç¨‹å¼ç¢¼è§£é‡‹:å·¦å³å…©ç«¯é»åœ¨è¿´åœˆå…§ä¸æ–·æ¯”è¼ƒï¼Œä»¥æ­¤æ‰¾å‡ºæœ€å¤§å€¼ï¼Œå­˜å–åˆ°æ–°é™£åˆ—ä¸­ã€‚

â˜ï¸[LeetCodeé€£çµ](https://leetcode.com/problems/squares-of-a-sorted-array/description/)
â˜ï¸[My_LeetCode_Sol](https://github.com/littleyu0820/Interview_Leetode/blob/main/Exercise/Squares_of_a_Sorted_Array.py)

### Exercise 4
>Minimum Size Subarray Sum(é•·åº¦æœ€å°çš„å­é™£åˆ—):Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.
### æ€è€ƒé‚è¼¯:é€šéå¿«æŒ‡é‡ç§»å‹•ä¾†æ‰¾å‡ºå…©æ ¹æŒ‡é‡çš„å’Œæ˜¯å¦å¤§æ–¼ç­‰æ–¼ç›®æ¨™å€¼äº†ã€‚å¦‚æœæ‰¾åˆ°äº†ï¼Œè¨ˆç®—é•·åº¦ï¼ŒåŒæ™‚å†å°‡æ…¢æŒ‡é‡å‘å³ç§»ä¸€æ ¼ï¼Œç¹¼çºŒåˆ¤æ–·ã€‚
>Solution:
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        size = len(nums)
        left_pointer = 0
        right_pointer = 0 #right_pointer is the pointer keeps moving
        sublength = float('inf')
        cur_sum = 0 
        while(right_pointer < size):
            cur_sum += nums[right_pointer]

            #check whether cur_sum is greater than target or not. sometimes when we minus nums[left_pointer] cur_sum will still be greater than thetarget
            while(cur_sum >= target):
                sublength = min(sublength, right_pointer - left_pointer + 1)
                cur_sum -= nums[left_pointer]
                left_pointer += 1
              
            right_pointer += 1
        return sublength if sublength != float('inf') else 0
```
â˜ï¸[LeetCodeé€£çµ](https://leetcode.com/problems/minimum-size-subarray-sum/description/)
â˜ï¸[My_LeetCode_Sol](https://github.com/littleyu0820/Interview_Leetode/blob/main/Exercise/Minimum_Size_Subarray_Sum.py)

### Exercise 5 
>Spiral Matrix II(èºæ—‹çŸ©é™£):Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
### æ€è€ƒé‚è¼¯:å¦‚æˆ‘å€‘åœ¨äºŒåˆ†æœå°‹æ³•æ™‚æ‰€æåˆ°çš„ï¼Œæˆ‘å€‘çš„æ¯ä¸€æ¬¡è¿´åœˆæ‰€æ“ä½œçš„æ–¹å¼éƒ½è¦ä¸€æ¨£ï¼Œåœ¨æ­¤é¡Œæˆ‘å€‘çµ±ä¸€çš„è¨­æƒ³æ˜¯å·¦é–‰å³é–‹ï¼Œä»£è¡¨è‘—æ¯ä¸€æ¬¡å³é‚Šçš„ç«¯é»æˆ‘å€‘éƒ½ä¸è€ƒæ…®ã€‚
![Spiral Matrix](https://github.com/littleyu0820/Interview_Leetode/blob/main/PitcturesForLearning/Spiral_Matrix.png)
>Solution:
```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        i, j =  0, 0
        nums = [[0] * n for _ in range(n)]
        counter = 1
        loop = n//2
        mid = n//2
        for offset in range(1, loop + 1):
            for run in range(j, n - offset):
                nums[i][run] = counter
                counter += 1
            for run in range(i, n - offset):
                nums[run][n - offset] = counter
                counter += 1
            for run in range(n - offset, j, -1):
                nums[n - offset][run] = counter
                counter += 1
            for run in range(n - offset, i, -1):
                nums[run][j] = counter
                counter += 1           
            i += 1
            j += 1
        if n % 2 != 0:
            nums[mid][mid] = counter
        return nums       
```
â˜ï¸[LeetCodeé€£çµ](https://leetcode.com/problems/spiral-matrix-ii/description/)
â˜ï¸[My_LeetCode_Sol](https://github.com/littleyu0820/Interview_Leetode/blob/main/Exercise/Spiral_Matrix.py)

### Exercise 6
>Remove Linked List Elements(ç§»é™¤åˆ—è¡¨å…ƒç´ ):Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
### æ€è€ƒé‚è¼¯:ä¾é listæ˜¯é€šéæŒ‡é‡çš„æ–¹å¼ä¾†é€£æ¥çš„æƒ³æ³•ï¼Œåªè¦å°‡nextçš„ç›®çš„åœ°æ”¹å‘å¾Œä¸€å€‹å°±å¯ä»¥äº†ã€‚
>Solution:
```C++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
        ListNode* vhead = new ListNode(0); //create a virtual head
        vhead->next = head;
        ListNode* cur = vhead;
        while(cur->next != NULL)
        {
            if(cur->next->val == val)
            {
               ListNode* tmp = cur->next;
               cur->next = cur->next->next;
               delete tmp;
            }
            else
            {
                cur = cur->next;
            }
        }
        head = vhead->next;
        delete vhead;
        return head;
    }   
```
â˜ï¸[LeetCodeé€£çµ](https://leetcode.com/problems/remove-linked-list-elements/description/)
â˜ï¸[My_LeetCode_Sol](https://github.com/littleyu0820/Interview_Leetode/blob/main/Exercise/Remove%20Linked%20List%20Elements_V2.cpp)
